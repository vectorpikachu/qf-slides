[
  {
    "objectID": "NSD_Lec03-BlackMertonScholes-1_Summer2025.html",
    "href": "NSD_Lec03-BlackMertonScholes-1_Summer2025.html",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "",
    "text": "Tai-Ho Wang (王 太和)\n\n\\[\n\\newcommand{\\bea}{\\begin{eqnarray}}\n\\newcommand{\\eea}{\\end{eqnarray}}\n\\newcommand{\\supp}{\\mathrm{supp}}\n\\newcommand{\\cA}{\\mathcal{A} }\n\\newcommand{\\F}{\\mathcal{F} }\n\\newcommand{\\cF}{\\mathcal{F} }\n\\newcommand{\\E}{\\mathbb{E} }\n\\newcommand{\\Eof}[1]{\\mathbb{E}\\left[ #1 \\right]}\n\\newcommand{\\Etof}[1]{\\mathbb{E}_t\\left[ #1 \\right]}\n\\newcommand{\\Sdof}[1]{\\mathbb{Sd}\\left[ #1 \\right]}\n\\def\\Cov{{ \\mbox{Cov} }}\n\\def\\Var{{ \\text{Var} }}\n\\newcommand{\\1}{\\mathbf{1} }\n\\newcommand{\\p}{\\partial}\n\\newcommand{\\PP}{\\mathbb{P} }\n\\newcommand{\\Pof}[1]{\\mathbb{P}\\left[ #1 \\right]}\n\\newcommand{\\QQ}{\\mathbb{Q} }\n\\renewcommand{\\R}{\\mathbb{R} }\n\\newcommand{\\DD}{\\mathbb{D} }\n\\newcommand{\\HH}{\\mathbb{H} }\n\\newcommand{\\spn}{\\mathrm{span} }\n\\newcommand{\\cov}{\\mathrm{cov} }\n\\newcommand{\\HS}{\\mathcal{L}_{\\mathrm{HS}} }\n\\newcommand{\\Hess}{\\mathrm{Hess} }\n\\newcommand{\\trace}{\\mathrm{trace} }\n\\newcommand{\\LL}{\\mathcal{L} }\n\\newcommand{\\s}{\\mathcal{S} }\n\\newcommand{\\ee}{\\mathcal{E} }\n\\newcommand{\\ff}{\\mathcal{F} }\n\\newcommand{\\hh}{\\mathcal{H} }\n\\newcommand{\\bb}{\\mathcal{B} }\n\\newcommand{\\dd}{\\mathcal{D} }\n\\newcommand{\\g}{\\mathcal{G} }\n\\newcommand{\\half}{\\frac{1}{2} }\n\\newcommand{\\T}{\\mathcal{T} }\n\\newcommand{\\bit}{\\begin{itemize}}\n\\newcommand{\\eit}{\\end{itemize}}\n\\newcommand{\\beq}{\\begin{equation}}\n\\newcommand{\\eeq}{\\end{equation}}\n\\newcommand{\\tr}{\\mbox{tr}}\n\\newcommand{\\inn}[2]{\\left\\langle #1, #2 \\right\\rangle}\n\\newcommand{\\bX}{\\boldsymbol X}\n\\renewcommand{\\bm}{\\boldsymbol m}\n\\newcommand{\\bx}{\\boldsymbol x}\n\\newcommand{\\by}{\\boldsymbol y}\n\\newcommand{\\bmu}{\\boldsymbol\\mu}\n\\newcommand{\\bxi}{\\boldsymbol\\xi}\n\\]"
  },
  {
    "objectID": "NSD_Lec03-BlackMertonScholes-1_Summer2025.html#lecture-3-the-black-merton-scholes-model-and-beyond-i",
    "href": "NSD_Lec03-BlackMertonScholes-1_Summer2025.html#lecture-3-the-black-merton-scholes-model-and-beyond-i",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "",
    "text": "Tai-Ho Wang (王 太和)\n\n\\[\n\\newcommand{\\bea}{\\begin{eqnarray}}\n\\newcommand{\\eea}{\\end{eqnarray}}\n\\newcommand{\\supp}{\\mathrm{supp}}\n\\newcommand{\\cA}{\\mathcal{A} }\n\\newcommand{\\F}{\\mathcal{F} }\n\\newcommand{\\cF}{\\mathcal{F} }\n\\newcommand{\\E}{\\mathbb{E} }\n\\newcommand{\\Eof}[1]{\\mathbb{E}\\left[ #1 \\right]}\n\\newcommand{\\Etof}[1]{\\mathbb{E}_t\\left[ #1 \\right]}\n\\newcommand{\\Sdof}[1]{\\mathbb{Sd}\\left[ #1 \\right]}\n\\def\\Cov{{ \\mbox{Cov} }}\n\\def\\Var{{ \\text{Var} }}\n\\newcommand{\\1}{\\mathbf{1} }\n\\newcommand{\\p}{\\partial}\n\\newcommand{\\PP}{\\mathbb{P} }\n\\newcommand{\\Pof}[1]{\\mathbb{P}\\left[ #1 \\right]}\n\\newcommand{\\QQ}{\\mathbb{Q} }\n\\renewcommand{\\R}{\\mathbb{R} }\n\\newcommand{\\DD}{\\mathbb{D} }\n\\newcommand{\\HH}{\\mathbb{H} }\n\\newcommand{\\spn}{\\mathrm{span} }\n\\newcommand{\\cov}{\\mathrm{cov} }\n\\newcommand{\\HS}{\\mathcal{L}_{\\mathrm{HS}} }\n\\newcommand{\\Hess}{\\mathrm{Hess} }\n\\newcommand{\\trace}{\\mathrm{trace} }\n\\newcommand{\\LL}{\\mathcal{L} }\n\\newcommand{\\s}{\\mathcal{S} }\n\\newcommand{\\ee}{\\mathcal{E} }\n\\newcommand{\\ff}{\\mathcal{F} }\n\\newcommand{\\hh}{\\mathcal{H} }\n\\newcommand{\\bb}{\\mathcal{B} }\n\\newcommand{\\dd}{\\mathcal{D} }\n\\newcommand{\\g}{\\mathcal{G} }\n\\newcommand{\\half}{\\frac{1}{2} }\n\\newcommand{\\T}{\\mathcal{T} }\n\\newcommand{\\bit}{\\begin{itemize}}\n\\newcommand{\\eit}{\\end{itemize}}\n\\newcommand{\\beq}{\\begin{equation}}\n\\newcommand{\\eeq}{\\end{equation}}\n\\newcommand{\\tr}{\\mbox{tr}}\n\\newcommand{\\inn}[2]{\\left\\langle #1, #2 \\right\\rangle}\n\\newcommand{\\bX}{\\boldsymbol X}\n\\renewcommand{\\bm}{\\boldsymbol m}\n\\newcommand{\\bx}{\\boldsymbol x}\n\\newcommand{\\by}{\\boldsymbol y}\n\\newcommand{\\bmu}{\\boldsymbol\\mu}\n\\newcommand{\\bxi}{\\boldsymbol\\xi}\n\\]"
  },
  {
    "objectID": "NSD_Lec03-BlackMertonScholes-1_Summer2025.html#agenda",
    "href": "NSD_Lec03-BlackMertonScholes-1_Summer2025.html#agenda",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "Agenda",
    "text": "Agenda\n\nBlack-Merton-Scholes model\nBlack-Merton-Scholes formula for call and put options\nGreeks\nSubtlety in self-financing\nDelta and delta-gamma hedges\nDynamic hedging\nDeep hedging\n\n\nRemark\n\nBlack-Merton-Scholes 模型是用于期权定价的经典模型\nCall option: 看涨期权; Put option: 看跌期权\nGreeks 是衡量期权价格对市场变量变化敏感度的指标\n自融资策略(self-financing)是指在不注入额外资金的情况下进行投资组合调整.\nhedging 是指通过对冲策略来降低风险. 对冲指通过调整标的资产的数量, 使得投资组合的价值对市场变量的变化不敏感.\n\nDelta 对冲, 投资组合对标的资产价格的一阶变动免疫\nDelta-Gamma 对冲, 投资组合对标的资产价格的二阶变动免疫\n\nDynamic Hedging\n\n动态对冲是指在期权到期前, 根据市场变化不断调整投资组合, 以保持对冲效果.\nDeep Hedging 是指使用深度学习模型来优化动态对冲策略, 通过学习历史数据中的模式来提高对冲效果."
  },
  {
    "objectID": "NSD_Lec03-BlackMertonScholes-1_Summer2025.html#black-merton-scholes",
    "href": "NSD_Lec03-BlackMertonScholes-1_Summer2025.html#black-merton-scholes",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "Black-Merton-Scholes",
    "text": "Black-Merton-Scholes\nFrom the Wikipage:\n\nThe Black–Scholes or Black–Scholes–Merton model is a mathematical model for the dynamics of a financial market containing derivative investment instruments. From the partial differential equation in the model, known as the Black–Scholes equation, one can deduce the Black–Scholes formula, which gives a theoretical estimate of the price of European-style options and shows that the option has a unique price regardless of the risk of the security and its expected return (instead of replacing the security’s expected return with the risk-neutral rate). The formula led to a boom in options trading and provided mathematical legitimacy to the activities of the Chicago Board Options Exchange and other options markets around the world. It is widely used, although often with adjustments and corrections, by options market participants.\nThe key idea behind the model is to hedge the option by buying and selling the underlying asset in just the right way and, as a consequence, to eliminate risk. This type of hedging is called “continuously revised delta hedging” and is the basis of more complicated hedging strategies such as those engaged in by investment banks and hedge funds.\nThe Black–Scholes formula has only one parameter that cannot be directly observed in the market: the average future volatility of the underlying asset, though it can be found from the price of other options. Since the option value (whether put or call) is increasing in this parameter, it can be inverted to produce a “volatility surface” (implied volatility) that is then used to calibrate other models ((exotic) derivatives), e.g. for OTC derivatives."
  },
  {
    "objectID": "NSD_Lec03-BlackMertonScholes-1_Summer2025.html#the-black-scholes-world",
    "href": "NSD_Lec03-BlackMertonScholes-1_Summer2025.html#the-black-scholes-world",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "The Black-Scholes world",
    "text": "The Black-Scholes world\nThe Black–Scholes model assumes that the market consists of at least one risky asset, usually called the stock, and one riskless asset, usually called the money market, cash, or bond.\nAssumptions on the assets:\n\n(riskless rate) The rate of return on the riskless asset is constant and thus called the risk-free interest rate.\n(Brownian motion) The instantaneous log return of stock price is a Brownian motion with drift; and we will assume its drift and volatility are constant (if they are time-varying, we can deduce a suitably modified Black–Scholes formula quite simply, as long as the volatility is not random). As a result, the stock price follows a geometric Brownian motion.\nThe stock does not pay dividend.\n\nAssumptions on the market:\n\nThere exists no arbitrage opportunity.\nIt is possible to borrow and lend any amount, even fractional, of cash at the riskless rate.\nIt is possible to buy and sell any amount, even fractional, of the stock, including short selling.\nFrictionless market: the transactions do not incur any fees or costs."
  },
  {
    "objectID": "NSD_Lec03-BlackMertonScholes-1_Summer2025.html#black-scholes-model",
    "href": "NSD_Lec03-BlackMertonScholes-1_Summer2025.html#black-scholes-model",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "Black-Scholes model",
    "text": "Black-Scholes model\nAssume the price of the underlying asset follows the stochastic differential equation\n\\[\n\\frac{{\\rm d}S_t}{S_t} = \\mu {\\rm d}t + \\sigma {\\rm d}W_t,\n\\]\nwhere\n\n\\(\\mu\\): (constant) expected return\n\\(\\sigma\\): (constant) volatility\n\\(W_t\\): standard Brownian motion\n\nFor each time \\(t\\), \\(S_t\\) is log-normally distributed. More precisely,\n\\[\nS_t \\sim S_0 \\exp\\left[\\left(\\mu - \\frac{\\sigma^2}{2}\\right)t + \\sigma \\sqrt t Z \\right]\n\\]\nwhere \\(Z\\) is a standard normal random variable.\n\nNote\n\\(S_t\\) has the closed form expression\n\\[\nS_t = S_0 e^{\\left(\\mu - \\frac{\\sigma^2}2 \\right) t+ \\sigma W_t}\n\\]\nand is also referred to as a geometric Brownian motion.\nThe price can never be negative, i.e., \\(S_t \\geq 0\\) for all \\(t \\geq 0\\)."
  },
  {
    "objectID": "NSD_Lec03-BlackMertonScholes-1_Summer2025.html#pricing-under-the-black-scholes-model",
    "href": "NSD_Lec03-BlackMertonScholes-1_Summer2025.html#pricing-under-the-black-scholes-model",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "Pricing under the Black-Scholes model",
    "text": "Pricing under the Black-Scholes model\nAssume the price of a call option \\(C\\) is a (smooth enough) function of the calendar time \\(t\\) and the underlying asset \\(S\\). Consider the portfolio \\(\\Pi\\) consisting of selling a call option and holding \\(\\Delta\\) shares of \\(S\\).\n\nThe value of \\(\\Pi\\) at time \\(t\\) is \\[\n\\Pi_t =  -C(t, S_t) + \\Delta S_t\n\\]\n Self-financing strategy \n\n\\[\n{\\rm d} \\Pi_t =  -{\\rm d}C_t + \\Delta {\\rm d}S_t\n\\]\n\nThe change of call price is given by\n\n\\[\\begin{equation}\n\\begin{aligned}\n  {\\rm d}C(t, S_t) &= C_t \\, {\\rm d}t + C_S \\, {\\rm d}S_t + \\frac{1}{2} C_{SS} ({\\rm d}S_t)^2 \\\\\n             &= C_S \\sigma S \\, {\\rm d}W_t + \\left( C_t + \\frac{1}{2} \\sigma^2 S^2 C_{SS} + \\mu S C_S \\right) {\\rm d}t\n\\end{aligned}\n\\end{equation}\\]\n\nHence the infinitesimal change of \\(\\Pi\\) at time \\(t\\) is\n\n\\[\\begin{equation}\n\\begin{aligned}\n  {\\rm d} \\Pi_t &= -{\\rm d}C_t + \\Delta \\, {\\rm d}S_t \\\\\n          &= -\\left[ C_t + \\frac{1}{2} \\sigma^2 S^2 C_{SS} + \\mu S (C_S - \\Delta) \\right] {\\rm d}t - \\sigma S (C_S - \\Delta) \\, {\\rm d}W_t\n\\end{aligned}\n\\end{equation}\\]\n\nNote\n\\(({\\rm d}S_t)^2 = \\sigma^2 S_t^2 {\\rm d}t\\)\n\nLet \\(\\Delta = C_S\\), i.e., hold this amount \\(C_S(t,S_t)\\) of underlying assets in the portfolio \\(\\Pi\\). Then the infinitesimal change of \\(\\Pi\\) becomes\n\n\\[\n\\displaystyle {\\rm d}\\Pi_t = -\\left( C_t + \\frac12 \\sigma^2 S^2 C_{SS} \\right) {\\rm d}t\n\\]\n\nOn the other hand, with this choice of \\(\\Delta\\), \\(\\Pi\\) is riskless (non-random) hence must be like cash in bank account (Arbitrage Pricing Theory), i.e.,\n\n\\[\n{\\rm d}\\Pi_t = r \\Pi_t {\\rm d}t = r(-C + \\Delta S){\\rm d}t = r(-C + C_S S) {\\rm d}t,\n\\]\nwhere \\(r\\) is the interest rate."
  },
  {
    "objectID": "NSD_Lec03-BlackMertonScholes-1_Summer2025.html#black-scholes-pde",
    "href": "NSD_Lec03-BlackMertonScholes-1_Summer2025.html#black-scholes-pde",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "Black-Scholes PDE",
    "text": "Black-Scholes PDE\nWe conclude that the price \\(C\\) of a call option satisfies\n\\[\\begin{equation}\n\\begin{aligned}\n  \\frac{\\partial C}{\\partial t} + \\frac{\\sigma^2}{2} S^2 \\frac{\\partial^2 C}{\\partial S^2} + rS \\frac{\\partial C}{\\partial S} - rC = 0,\n  \\quad \\text{for } 0 &lt; S &lt; \\infty, \\quad 0 \\leq t &lt; T\n\\end{aligned}\n\\end{equation}\\]\nwith terminal condition\n\\[\nC(T,S) = (S - K)^+\n\\]\nand boundary conditions\n\\[\\begin{equation}\n\\begin{aligned}\n  && C(t, 0) = 0, \\\\\n  && C(t, S) \\sim S - K e^{-r(T-t)} \\quad \\text{as } S \\to \\infty, \\\\\n  && \\text{or more specifically} \\quad \\lim_{S \\to \\infty} \\frac{C(t, S)}{S} = 1.\n\\end{aligned}\n\\end{equation}\\]\n\nNote\nThe Black-Scholes pricing PDE does not depend on the drift \\(\\mu\\).\n\\(C(T,S) = (S-K)^+\\) 表示欧式看涨期权在到期时(\\(t= T\\))的支付函数. 若股价高于执行价 \\(K\\), 则价值是差额; 否则归零.\n这里的 PDE 是通过 Feynamn-Kac 定理得到的:\n\\[\\begin{align*}\n{\\rm d} S_t &= r S_t {\\rm d} t + \\sigma S_t {\\rm d} W_t \\\\\nC(t,s) &= \\Eof{e^{-r(T-t)} (S_T - K)^+ \\mid S_t = s}\n\\end{align*}\\]\n那么 PDE 就是 \\[\n\\frac{\\partial C}{\\partial t} + r S \\frac{\\partial C}{\\partial S} + \\frac{\\sigma^2}{2} S^2 \\frac{\\partial^2 C}{\\partial S^2} - r C = 0.\n\\]"
  },
  {
    "objectID": "NSD_Lec03-BlackMertonScholes-1_Summer2025.html#solving-black-scholes-pde",
    "href": "NSD_Lec03-BlackMertonScholes-1_Summer2025.html#solving-black-scholes-pde",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "Solving Black-Scholes PDE",
    "text": "Solving Black-Scholes PDE\n\\[\n\\frac{\\p C}{\\p t} + \\frac{\\sigma^2}{2}S^2\\frac{\\p C^2}{\\p S^2} + rS\\frac{\\p C}{\\p S} - rC = 0\n\\]\n\n\\(\\tau = T - t\\)\n\n\\[\n\\frac{\\p C}{\\p \\tau} = \\frac{\\sigma^2}{2}S^2\\frac{\\p C^2}{\\p S^2} + rS\\frac{\\p C}{\\p S} - rC\n\\]\n\n\\(\\xi = \\ln S\\)\n\n\\[\n\\frac{\\p C}{\\p \\tau} = \\frac{\\sigma^2}{2}\\frac{\\p C^2}{\\p \\xi^2} + \\left( r -\\frac{\\sigma^2}{2} \\right) \\frac{\\p C}{\\p \\xi} - rC\n\\]\n\n\\(c(\\xi,\\tau) = e^{r\\tau}C(\\xi,\\tau)\\)\n\n\\[\n\\frac{\\p c}{\\p \\tau} = \\frac{\\sigma^2}{2}\\frac{\\p c^2}{\\p \\xi^2} + \\left( r -\\frac{\\sigma^2}{2} \\right) \\frac{\\p c}{\\p \\xi}\n\\]\n\n\\(\\displaystyle x = \\xi + \\left( r - \\frac{\\sigma^2}{2} \\right) \\tau\\)\n\n\\[\n\\frac{\\p c}{\\p \\tau} = \\frac{\\sigma^2}{2} \\frac{\\p^2 c}{\\p x^2}\n\\]\nIn total, we have done the transformation\n\\[\\begin{equation}\n\\begin{aligned}\n  \\tau &= T - t, \\\\\n  x &= \\ln S + \\left( r - \\frac{\\sigma^2}{2} \\right) (T - t), \\\\\n  c &= e^{r(T-t)} C.\n\\end{aligned}\n\\end{equation}\\]\nwhich transforms Black-Scholes equation into heat equation."
  },
  {
    "objectID": "NSD_Lec03-BlackMertonScholes-1_Summer2025.html#the-black-scholes-formula",
    "href": "NSD_Lec03-BlackMertonScholes-1_Summer2025.html#the-black-scholes-formula",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "The Black-Scholes formula",
    "text": "The Black-Scholes formula\n\nFor call option\n\n\\[\nC = S e^{-d\\tau} N(d_1) - K e^{-r\\tau} N(d_2)\n\\]\nwhere \\(\\tau\\) is time to expiry, \\(N(\\cdot)\\) denotes the cdf for standard normal, and\n\\[\nd_1 = \\frac{\\log\\left(\\frac{Se^{-d\\tau}}{Ke^{-r\\tau}}\\right)}{\\sigma\\sqrt\\tau}+ \\frac{\\sigma\\sqrt\\tau}2, \\qquad d_2 = d_1 - \\sigma \\sqrt\\tau\n\\]\n注:\n\n\n\nTerm\nEconomic meaning\n\n\n\n\n\\(S e^{-d\\tau} N(d_1)\\)\nDividend discounted stock price\n\n\n\\(K e^{-r\\tau}\\)\nPresent value of strike price\n\n\n\\(N(d_2)\\)\nThe probability of the option expires in the money.\n\n\n\n注: in the money = 实值, at the money = 平值, out of the money = 虚值.\nin the money = the option is worth exercising at expiry, i.e., \\(S_T &gt; K\\).\nThe \\(N(d_1)\\) is the factor by which the present value of contingent(有条件的) receipt(收入) of the stock, contingent on exercise, exceeds the current value of the stock.\nThe \\(N(d_2)\\) is the risk-adjusted probability of exercise.\n\nFor put option\n\n\\[\nP = K e^{-r\\tau} N(-d_2) - S e^{-d\\tau} N(-d_1).\n\\]\n\\(\\tau = T - t\\)\n\nNote\n\nPut-call parity\n\\[\n  C - P = S e^{-d\\tau} - K e^{-r\\tau}.\n  \\]\nFinancial meaning of \\(N(d_1)\\) and \\(N(d_2)\\)\n\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport pandas as pd\nfrom numpy import exp, log, sqrt\nfrom scipy.stats import norm\n\n\nnorm.rvs(size=10) # generate samples from standard normal \nnorm.cdf # cdf of standard normal\nnorm.pdf # pdf for standard normal\nnorm.ppf # quantile funciton\n\n&lt;bound method rv_continuous.ppf of &lt;scipy.stats._continuous_distns.norm_gen object at 0x00000164E2712660&gt;&gt;\n\n\n\nprint(norm.cdf(0)) # This is N(0) in our notation\nnorm.cdf((-9, -2, -1, 0, 1, 2, 3, 4, 9))\n\n0.5\n\n\narray([1.12858841e-19, 2.27501319e-02, 1.58655254e-01, 5.00000000e-01,\n       8.41344746e-01, 9.77249868e-01, 9.98650102e-01, 9.99968329e-01,\n       1.00000000e+00])\n\n\n\n# plot cdf and pdf for standard normal\nx = np.linspace(-3, 3, 201)\ny = norm.cdf(x)\nplt.figure(figsize=(9, 6))\nplt.title('Standard normal CDF and PDF', fontsize=20)\nplt.plot(x, y, lw=1)\ny = norm.pdf(x)\nplt.plot(x, y, color='green', ls='dashdot', lw=3);\n\n\n\n\n\n\n\n\n\n# Black-Scholes formulas\n# call\n# t is tau in the formula above\ndef bs_call(s, K, sigma, t, r=0, d=0):\n    d1 = (log(s/K) + (r - d)*t)/(sigma*sqrt(t)) + sigma*sqrt(t)/2\n    d2 = d1 - sigma*sqrt(t)\n    \n    c = s*exp(-d*t)*norm.cdf(d1) - K*exp(-r*t)*norm.cdf(d2)\n    delta = exp(-d*t)*norm.cdf(d1)\n    gamma = exp(-d*t)*norm.pdf(d1)/s/sigma/sqrt(t)\n    \n    return {'c': c, 'delta': delta, 'gamma': gamma}\n\n#put\ndef bs_put(s, K, sigma, t, r=0, d=0):\n    d1 = (log(s/K) + (r - d)*t)/(sigma*sqrt(t)) + sigma*sqrt(t)/2\n    d2 = d1 - sigma*sqrt(t)\n    \n    p = K*exp(-r*t)*norm.cdf(-d2) - s*exp(-d*t)*norm.cdf(-d1)\n    delta = -exp(-d*t)*norm.cdf(-d1)\n    gamma = exp(-d*t)*norm.pdf(d1)/s/sigma/sqrt(t)\n    \n    return {'p': p, 'delta': delta, 'gamma': gamma}\n\n\nprint(bs_call(K=100, s=100, sigma=0.3, t=1))\nprint(bs_call(K=100, s=102, sigma=0.3, t=1))\nprint(bs_call(K=100, s=100, t=1, sigma=.3, r=0.05))\nprint(bs_call(s=100, K=90, t=1, sigma=.3))\n\n{'c': 11.923538474048499, 'delta': 0.5596176923702425, 'gamma': 0.013149311030262966}\n{'c': 13.068803286156744, 'delta': 0.5855095394527341, 'gamma': 0.012736690514019119}\n{'c': 14.231254785985826, 'delta': 0.6242517279060125, 'gamma': 0.012647764437231514}\n{'c': 17.0128799018497, 'delta': 0.6918854176337346, 'gamma': 0.011728453149086748}\n\n\n\n# option price as a function of the underlying\nK, sig, T, r = 100, 0.3, 1, 0.05 #0.02\n\n# payoffs of call and put\npayoff_c = lambda s, k: (s - k)*(s &gt; k)\npayoff_p = lambda s, k: (k - s)*(k &gt; s)\n\n# some temp functions\ntmpc = lambda x: bs_call(x, K, sig, T, r)['c']\ntmpp = lambda x: bs_put(x, K, sig, T, r)['p']\ntmp_payoff_c = lambda x: payoff_c(x, K)\ntmp_payoff_p = lambda x: payoff_p(x, K)\n\n# plot\nx = np.linspace(50, 150, 201)\nplt.figure(figsize=(15, 6))\nplt.subplot(1, 2, 1)\ny = tmpc(x)\nplt.plot(x, y, label='Black-Scholes')\ny = tmp_payoff_c(x)\nplt.plot(x, y, color='red', ls='dashed', label='payoff')\nplt.xlabel(r'$S$', fontsize=15)\nplt.ylabel('call price', fontsize=15)\nplt.legend()\nplt.subplot(1, 2, 2)\ny = tmpp(x)\nplt.plot(x, y, label='Black-Scholes')\ny = tmp_payoff_p(x)\nplt.plot(x, y, color='red', ls='dashed', label='payoff')\nplt.xlabel(r'$S$', fontsize=15)\nplt.ylabel('put price', fontsize=15)\nplt.legend();\n\n\n\n\n\n\n\n\n\n# option price as a function of strike\ns, sig, T = 100, 0.3, 1\n\ntmpc = lambda x: bs_call(s, x, sig, T)['c']\ntmpp = lambda x: bs_put(s, x, sig, T)['p']\n\n# plot\nx = np.linspace(50, 150, 201)\nplt.figure(figsize=(15, 6))\nplt.subplot(1, 2, 1)\ny = tmpc(x)\nplt.plot(x, y, label='Black-Scholes')\nplt.xlabel(r'$K$', fontsize=15)\nplt.ylabel('call price', fontsize=15)\nplt.subplot(1, 2, 2)\ny = tmpp(x)\nplt.plot(x, y, label='Black-Scholes')\nplt.xlabel(r'$K$', fontsize=15)\nplt.ylabel('put price', fontsize=15);\n\n\n\n\n\n\n\n\n\n# option price as a function of volatility\ns, K, T = 100, 95, 1\n\ntmpc = lambda x: bs_call(s, K, x, T)['c']\ntmpp = lambda x: bs_put(s, K, x, T)['p']\n\n# plot\nx = np.linspace(0.05, 1.5, 201)\nplt.figure(figsize=(15, 6))\nplt.subplot(1, 2, 1)\ny = tmpc(x)\nplt.plot(x, y, label='Black-Scholes')\nplt.xlabel(r'$\\sigma$', fontsize=15)\nplt.ylabel('call price', fontsize=15)\nplt.subplot(1, 2, 2)\ny = tmpp(x)\nplt.plot(x, y, label='Black-Scholes')\nplt.xlabel(r'$\\sigma$', fontsize=15)\nplt.ylabel('put price', fontsize=15);\n\n\n\n\n\n\n\n\n\n# option price as a function of time to expiry\ns, K, sigma = 100, 102, 0.3\n\ntmpc = lambda x: bs_call(s, K, sigma, x)['c']\ntmpp = lambda x: bs_put(s, K, sigma, x)['p']\n\n# plot\nx = np.linspace(0.01, 2, 201)\nplt.figure(figsize=(15, 6))\nplt.subplot(1, 2, 1)\ny = tmpc(x)\nplt.plot(x, y, label='Black-Scholes')\nplt.xlabel('Time to expiry', fontsize=15)\nplt.ylabel('call price', fontsize=15)\nplt.subplot(1, 2, 2)\ny = tmpp(x)\nplt.plot(x, y, label='Black-Scholes')\nplt.xlabel('Time to expiry', fontsize=15)\nplt.ylabel('put price', fontsize=15);"
  },
  {
    "objectID": "NSD_Lec03-BlackMertonScholes-1_Summer2025.html#sensitivities-of-option-prices-in-black-scholes-model---the-greeks",
    "href": "NSD_Lec03-BlackMertonScholes-1_Summer2025.html#sensitivities-of-option-prices-in-black-scholes-model---the-greeks",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "Sensitivities of option prices in Black-Scholes model - the Greeks",
    "text": "Sensitivities of option prices in Black-Scholes model - the Greeks\nAssume the dividend rate \\(d = 0\\).\n注: 股利率(dividend rate) 是指公司向股东支付的利润分配率, 在 Black-Scholes 模型中通常假设为 \\(0\\).\n\nFor call:\n\n\\(\\displaystyle \\Delta_C = \\frac{\\p C}{\\p S} = N(d_1)\\)\nDual \\(\\displaystyle \\Delta_C^K = \\frac{\\p C}{\\p K} = -e^{-rT} N(d_2)\\)\n\\(\\displaystyle \\Gamma = \\frac{\\p^2 C}{\\p S^2} = \\frac{n(d_1)}{S\\sigma\\sqrt T}\\)\n\\(\\displaystyle \\Theta_C = \\frac{\\p C}{\\p T} = \\frac{S \\sigma}{2\\sqrt T} n(d_1) + r K e^{-rT} N(d_2)\\)\n\\(\\displaystyle \\nu \\, (\\text{vega}) = \\frac{\\p C}{\\p \\sigma} = S \\sqrt T \\, n(d_1)\\)\n\\(\\displaystyle \\rho_C = \\frac{\\p C}{\\p r} = K T e^{-rT} N(d_2)\\)\n\nFor put:\n\n\\(\\displaystyle \\Delta_P = \\frac{\\p P}{\\p S} = \\Delta_C - 1 = -N(-d_1)\\)\nDual \\(\\displaystyle \\Delta_P^K = \\frac{\\p P}{\\p K} = \\Delta_C^K + e^{-r T} = e^{-rT} N(-d_2)\\)\n\\(\\displaystyle \\Gamma = \\frac{\\p^2 P}{\\p S^2} = \\frac{\\p^2 C}{\\p S^2}\\)\n\\(\\displaystyle \\Theta_P = \\frac{\\p P}{\\p T} = \\Theta_C - r e^{-rT} K = \\frac{S \\sigma}{2\\sqrt T} n(d_1) - r K e^{-rT} N(-d_2)\\)\n\\(\\displaystyle \\nu \\, (\\text{vega}) = \\frac{\\p P}{\\p \\sigma} = \\frac{\\p C}{\\p \\sigma} = S \\sqrt T n(d_1)\\)\n\\(\\displaystyle \\rho_P = \\frac{\\p P}{\\p r} = \\rho_C - T e^{-rT} K = -K T e^{-rT} N(-d_2)\\)\n\n\n\nNote\n\n\\(n(x) = N'(x)\\) is the pdf for standard normal.\n\\(\\Theta_C &gt; 0\\), whereas \\(\\Theta_P\\) may be negative if \\(r &gt; 0\\)."
  },
  {
    "objectID": "NSD_Lec03-BlackMertonScholes-1_Summer2025.html#subtlety-in-self-financing",
    "href": "NSD_Lec03-BlackMertonScholes-1_Summer2025.html#subtlety-in-self-financing",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "Subtlety in self-financing",
    "text": "Subtlety in self-financing\nAssume that all the tradings are done at the mid price \\(S_t\\), i.e., no bid-ask spread and transaction cost.\nIn a discrete time setting, consider a portfolo consisting of holding \\(H_t\\) shares of the underlying and \\(K_t\\) dollars in the money/cash account at time \\(t\\), interest and dividend are assumed zero for simplicity.\nThe monetary value \\(V_t\\) of the porffolio, marked to market value at the mid price, is thus given by \\(V_t = H_tS_t + K_t\\) (before the price of the underlying changes from \\(S_t\\) to \\(S_{t+1}\\)). At this point, the investor may decide to change his portfolio before he observes the price change of the underlying from \\(S_t\\) to \\(S_{t+1}\\) or after the price change.\n\nBefore price change. In this case, the self-financing condition reads \\[\nV_t = H_t S_t + K_t = H_{t+1} S_t + K_{t+1},\n\\] where apparently \\(K_{t+1} = K_t + (H_t - H_{t+1}) S_t\\). In other words, the investor simply moves his money from stock to money account (or the other way around) without pouring/withdrawing extra money/shares into/out of the portfolio. The value of the porfolio (after price change) at time \\(t+1\\) is given by \\(V_{t+1} = H_{t+1}S_{t+1} + K_{t+1}\\). Hence, \\[\\begin{equation}\n\\begin{aligned}\n\\Delta V_{t+1} &= V_{t+1} - V_t \\\\\n               &= H_{t+1} S_{t+1} + K_{t+1} - (H_t S_t + K_t) \\\\\n               &= H_{t+1} S_{t+1} + K_{t+1} - (H_{t+1} S_t + K_{t+1}) \\\\\n               &= H_{t+1} \\Delta S_{t+1}.\n\\end{aligned}\n\\end{equation}\\]\n\nIf we write \\(H_{t+1} = H_t + \\Delta H_{t+1}\\), then\n\\[\n\\Delta V_{t+1} = H_t \\Delta S_{t+1} + \\Delta H_{t+1} \\Delta S_{t+1}\n\\]\n\nAfter price change. In this case, the self-financing condition becomes \\[\nV_{t+1} = H_t S_{t+1} + K_t = H_{t+1} S_{t+1} + K_{t+1},\n\\] where \\(K_{t+1} = K_t + (H_t - H_{t+1}) S_{t+1}\\). Hence, \\[\\begin{equation}\n\\begin{aligned}\n\\Delta V_{t+1} &= V_{t+1} - V_t \\\\\n               &= H_{t+1} S_{t+1} + K_{t+1} - (H_t S_t + K_t) \\\\\n               &= H_{t+1} S_{t+1} + K_t + (H_t - H_{t+1}) S_{t+1} - (H_t S_t + K_t) \\\\\n               &= H_t \\Delta S_{t+1}.\n\\end{aligned}\n\\end{equation}\\]\n\nThe subtlety results from the investor’s decision to rebalance his position before or after he observes the price change. Moreover, the discrepancy between the two increments of portfolio values is exactly the covariation between the holdings \\(H_t\\) and the price \\(S_t\\) of the underlying. In the continuous time limit, the discrepancy becomes insignificent should the covariation vanishes in the continuous time limit. In a recent paper by Carmona and Webster, the authors argued that, in the high frequency trading regime, empirically this covariation is statistically significant. As a result, the process of holdings \\(H_t\\) cannot be of finite variation, counterintuitive to common knowledge."
  },
  {
    "objectID": "NSD_Lec03-BlackMertonScholes-1_Summer2025.html#self-financing-with-traded-price",
    "href": "NSD_Lec03-BlackMertonScholes-1_Summer2025.html#self-financing-with-traded-price",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "Self-financing with traded price",
    "text": "Self-financing with traded price\nIn reality, trading incurs transaction cost which consist of bid-ask spread, fees, and taxes. The self-financing conditions with transaction cost becomes\n\nBefore price change. \\[\nV_t = H_t S_t + K_t = H_{t+1} S_t + K_{t+1} ,\n\\] where \\(K_{t+1} = K_t + (H_t - H_{t+1})S_t - c_t\\) and \\(c_t &gt; 0\\) denotes the transaction cost at time \\(t\\). Hence, the increment of \\(V\\) at time \\(t+1\\) \\[\\begin{equation}\n\\begin{aligned}\n\\Delta V_{t+1} &= V_{t+1} - V_t \\\\\n               &= H_{t+1} S_{t+1} + K_t + (H_t - H_{t+1}) S_t - c_t - (H_t S_t + K_t) \\\\\n               &= H_{t+1} \\Delta S_{t+1} - c_t \\\\\n               &= H_t \\Delta S_{t+1} + \\Delta H_{t+1} \\Delta S_{t+1} - c_t.\n\\end{aligned}\n\\end{equation}\\]\nAfter price change. By the same token, in this case one can show that \\[\\begin{equation}\n\\Delta V_{t+1} = H_t \\Delta S_{t+1} - c_{t+1}\n\\end{equation}\\]\n\nwhere the transaction cost \\(c_{t+1}\\) is incurred at time \\(t+1\\)."
  },
  {
    "objectID": "NSD_Lec03-BlackMertonScholes-1_Summer2025.html#delta-hedging",
    "href": "NSD_Lec03-BlackMertonScholes-1_Summer2025.html#delta-hedging",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "Delta hedging",
    "text": "Delta hedging\nThe portfolio used in deriving the Black-Scholes PDE is called delta-hedging.\n\nNote\nRebalancing of hedging porfolio is done after the price change.\n\n\nAn example on delta hedge\n\nr, sigma = 0, 0.3 \ns0, K = 10, 11\ndt = 1/252 # one day \nt = 1/4 # a quarter of year, 3 month\n\n# unpack a dict by using the .values method for dict object\nc, delta, _ = bs_call(s0, K, sigma, t, r).values()\nprint(f'call price = {c}, delta = {delta}') \nbs_call(s0, K, sigma, t, r)\n\ncall price = 0.25002448066930727, delta = 0.28760290709660397\n\n\n{'c': 0.25002448066930727,\n 'delta': 0.28760290709660397,\n 'gamma': 0.2273127644037836}\n\n\n\nprint(bs_call(s0, K, sigma, t, r))\nprint(bs_call(s0, K, sigma, t, r).values())\n\n{'c': 0.25002448066930727, 'delta': 0.28760290709660397, 'gamma': 0.2273127644037836}\ndict_values([0.25002448066930727, 0.28760290709660397, 0.2273127644037836])\n\n\n\n# a range of underlying prices one day later\ns = s0 + np.linspace(-1, 1, 21)\nprint(s)\n\nbs_call(s, K, sigma, t-dt, r)['c']\ndelta*s0 - c\n\n[ 9.   9.1  9.2  9.3  9.4  9.5  9.6  9.7  9.8  9.9 10.  10.1 10.2 10.3\n 10.4 10.5 10.6 10.7 10.8 10.9 11. ]\n\n\n2.6260045902967324\n\n\n\npnl_naked = c - bs_call(s, K, sigma, t-dt, r)['c']\npnl_delta = delta*s - bs_call(s, K, sigma, t-dt, r)['c'] - (delta*s0 - c)\npd.DataFrame({'naked': pnl_naked, 'delta_hedged': pnl_delta})\n\n\n\n\n\n\n\n\nnaked\ndelta_hedged\n\n\n\n\n0\n0.189399\n-0.098204\n\n\n1\n0.178589\n-0.080254\n\n\n2\n0.166344\n-0.063738\n\n\n3\n0.152554\n-0.048768\n\n\n4\n0.137110\n-0.035452\n\n\n5\n0.119905\n-0.023896\n\n\n6\n0.100837\n-0.014204\n\n\n7\n0.079807\n-0.006474\n\n\n8\n0.056725\n-0.000796\n\n\n9\n0.031504\n0.002744\n\n\n10\n0.004069\n0.004069\n\n\n11\n-0.025650\n0.003111\n\n\n12\n-0.057711\n-0.000190\n\n\n13\n-0.092164\n-0.005883\n\n\n14\n-0.129050\n-0.014009\n\n\n15\n-0.168397\n-0.024596\n\n\n16\n-0.210225\n-0.037664\n\n\n17\n-0.254544\n-0.053222\n\n\n18\n-0.301352\n-0.071269\n\n\n19\n-0.350638\n-0.091795\n\n\n20\n-0.402383\n-0.114780\n\n\n\n\n\n\n\n\n# plot\nplt.figure(figsize=(9, 6))\nplt.plot(s, pnl_naked, 'o-', label='Naked call')\nplt.plot(s, pnl_delta, 'o-.', color='orange', label='Delta hedged')\nplt.hlines(y=0, xmin=min(s), xmax=max(s), ls='dashed')\nplt.grid(color='grey', ls='dotted')\nplt.ylabel('P&L', fontsize=15)\nplt.xlabel(r'$s$', fontsize=15)\nplt.legend();\n\n\n\n\n\n\n\n\n\n# zoom into the interval [9.5, 10.5]\nplt.figure(figsize=(9, 6))\nplt.plot(s, pnl_naked, 'o-', label='Naked call')\nplt.plot(s, pnl_delta, 'o-.', color='orange', label='Delta hedged')\nplt.hlines(y=0, xmin=min(s), xmax=max(s), ls='dashed')\nplt.grid(color='grey', ls='dotted')\nplt.ylabel('P&L', fontsize=15)\nplt.xlabel(r'$s$', fontsize=15)\nplt.xlim(9.5, 10.5)\nplt.legend();"
  },
  {
    "objectID": "NSD_Lec03-BlackMertonScholes-1_Summer2025.html#an-exmaple-on-delta-gamma-hedge",
    "href": "NSD_Lec03-BlackMertonScholes-1_Summer2025.html#an-exmaple-on-delta-gamma-hedge",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "An exmaple on delta-gamma hedge",
    "text": "An exmaple on delta-gamma hedge\n Note \nThe gammas of the underlying and forward are zero. To construct a delta-gamma hedge portfolio we need to add into the portfolio an instrument that has nonzero gamma, say, call or put options.\n\\(C\\)\n\\(C_1\\)\n\n\\(\\displaystyle -\\Gamma_C +  x \\Gamma_{C1} = 0  \\Longrightarrow x = \\frac{\\Gamma_C}{\\Gamma_{C1}}\\)\n\\(\\displaystyle C + x C_1 + y S\\)\n\\(\\displaystyle -\\Delta_C + x \\Delta_{C1} + y = 0 \\Longrightarrow y = \\Delta_C - x \\Delta_{C1}\\)\n\n\nr, sigma, K, s0 = 0, 0.3, 11, 10\ndt, t = 1/252, 1/4\n\n# target call\nc, delta, gamma = bs_call(s0, K, sigma, t, r).values()\n\n# call for hedging\nK_hg = 14\nc_hg, delta_hg, gamma_hg = bs_call(s0, K_hg, sigma, t, r).values()\n\n# 1 day later\ns = s0 + np.linspace(-1, 1, 21)\ncs = bs_call(s, K, sigma, t-dt, r)['c']\npnl_naked = c - cs\npnl_delta = delta*s - cs - (delta*s0 - c)\ndelta_dg = delta - gamma/gamma_hg*delta_hg\ngamma_dg = gamma/gamma_hg\npnl_dg = delta_dg*s + gamma_dg*bs_call(s, K_hg, sigma, t-dt, r)['c'] - cs - (delta_dg*s0 + gamma_dg*c_hg  - c)\n\n# pandas.DataFrame for presentation\ndf = pd.DataFrame(np.array([pnl_naked, pnl_delta, pnl_dg]).transpose())\ndf.columns = ['naked', 'delta hedged', 'delta-gamma hedged']\ndf\n\n\n\n\n\n\n\n\nnaked\ndelta hedged\ndelta-gamma hedged\n\n\n\n\n0\n0.189399\n-0.098204\n-0.025266\n\n\n1\n0.178589\n-0.080254\n-0.018913\n\n\n2\n0.166344\n-0.063738\n-0.013499\n\n\n3\n0.152554\n-0.048768\n-0.009028\n\n\n4\n0.137110\n-0.035452\n-0.005487\n\n\n5\n0.119905\n-0.023896\n-0.002840\n\n\n6\n0.100837\n-0.014204\n-0.001027\n\n\n7\n0.079807\n-0.006474\n0.000038\n\n\n8\n0.056725\n-0.000796\n0.000471\n\n\n9\n0.031504\n0.002744\n0.000423\n\n\n10\n0.004069\n0.004069\n0.000075\n\n\n11\n-0.025650\n0.003111\n-0.000354\n\n\n12\n-0.057711\n-0.000190\n-0.000607\n\n\n13\n-0.092164\n-0.005883\n-0.000389\n\n\n14\n-0.129050\n-0.014009\n0.000633\n\n\n15\n-0.168397\n-0.024596\n0.002832\n\n\n16\n-0.210225\n-0.037664\n0.006620\n\n\n17\n-0.254544\n-0.053222\n0.012447\n\n\n18\n-0.301352\n-0.071269\n0.020799\n\n\n19\n-0.350638\n-0.091795\n0.032197\n\n\n20\n-0.402383\n-0.114780\n0.047194\n\n\n\n\n\n\n\n\n# plot\nplt.figure(figsize=(9, 6))\nplt.plot(s, pnl_naked, 'o-', label='Naked call')\nplt.plot(s, pnl_delta, 'o-.', color='orange', label='Delta hedged')\nplt.plot(s, pnl_dg, 'o-.', color='red', label='Delta Gamma hedged')\nplt.hlines(y=0, xmin=min(s), xmax=max(s), ls='dashed')\nplt.grid(color='grey', ls='dotted')\nplt.ylabel('P&L', fontsize=15)\nplt.xlabel(r'$s$', fontsize=15)\nplt.legend();\n\n\n\n\n\n\n\n\n\n# zoom into the interval [9.5, 10.5]\nplt.figure(figsize=(9, 6))\nplt.plot(s, pnl_naked, 'o-', label='Naked call')\nplt.plot(s, pnl_delta, 'o-.', color='orange', label='Delta hedged')\nplt.plot(s, pnl_dg, 'o-.', color='red', label='Delta Gamma hedged')\nplt.hlines(y=0, xmin=min(s), xmax=max(s), ls='dashed')\nplt.grid(color='grey', ls='dotted')\nplt.ylabel('P&L', fontsize=15)\nplt.xlabel(r'$s$', fontsize=15)\nplt.xlim(9.5, 10.5)\nplt.legend();"
  },
  {
    "objectID": "NSD_Lec03-BlackMertonScholes-1_Summer2025.html#dynamical-hedging",
    "href": "NSD_Lec03-BlackMertonScholes-1_Summer2025.html#dynamical-hedging",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "Dynamical hedging",
    "text": "Dynamical hedging\nAs market conditions evolve, to maintain the delta neutrality of the portfolio, ideally we should dynamically change the holdings in the porfolio. For example,\n\nNote\n\nRebalancing of hedging portfolio is done after observing the price change.\n\n\n\nAn example on dynamical hedging\n\n# parameters\nr, sigma = 0, 0.3\ns0, K = 10, 11\ndt, t, days_forward = 1/252, 1/4, 30\n\n# portfolio positions in cash, options, underlying\n# x : number of shares in underlying\n# y : dollars in cash\n# z : number of options\n\n# short 1000 calls\nz = -1000\n\n# current price and delta of call\nc, delta, _ = bs_call(s0, K, sigma, t, r).values()\n\n# construct a zero value and delta neutral portfolio\nx = delta*(-z)\ny = -(x*s0 + z*c)\nport_value, port_delta = x*s0 + y + z*c, x + z*delta\ns, pnl_cum = s0, 0\n\n# pandas.DataFrame for presentation\npd.DataFrame(np.array([port_value, port_delta, pnl_cum, s, c, x, y, z*delta]).reshape(1, 8))\n\n\n\n\n\n\n\n\n0\n1\n2\n3\n4\n5\n6\n7\n\n\n\n\n0\n-8.526513e-14\n0.0\n0.0\n10.0\n0.250024\n287.602907\n-2626.00459\n-287.602907\n\n\n\n\n\n\n\n\n# 1 day later\ni = 1\ns_new = s0*exp((r - sigma**2/2)*dt + sigma*sqrt(dt)*norm.rvs()) # sample a new stock price\nc_new, delta_new, _ = bs_call(s_new, K, sigma, t-i*dt, r).values()\n\n# portfolio value before rebalance \nport_value_new = x*s_new + y*exp(r*i*dt) + z*c_new\npnl_cum = pnl_cum + port_value_new - port_value\n\n# rebalance to delta neutral\nx_new = delta_new*(-z)\ny_new = y*exp(r*i*dt) + (x - x_new)*s_new\nport_value = x_new*s_new + y_new + z*c_new\nport_delta = x_new + z*delta_new\ns, c, x, delta, y = s_new, c_new, x_new, delta_new, y_new\n\n\n# display the result\npd.DataFrame(np.array([port_value, s, c, y, x]).reshape(1, 5))\n\n\n\n\n\n\n\n\n0\n1\n2\n3\n4\n\n\n\n\n0\n-14.015141\n9.602172\n0.149623\n-1792.110966\n200.75864\n\n\n\n\n\n\n\n\n# Let's see how it works for 30 days forward\n# initialize data\nport_value = np.zeros(days_forward+1)\ns = s0 + np.zeros(days_forward+1)\ncalls = c + np.zeros(days_forward+1)\ndeltas = delta + np.zeros(days_forward+1)\nshares = x + np.zeros(days_forward+1)\ncash = y + np.zeros(days_forward+1)\n\nfor i in range(days_forward):    \n    # sample a stock price\n    s[i+1] = s[i]*exp((r - sigma**2/2)*dt + sigma*sqrt(dt)*norm.rvs()) \n    \n    # calculate new call price and delta\n    calls[i+1], deltas[i+1], _ = bs_call(s[i+1], K, sigma, t-i*dt, r).values()\n    \n    # portfolio value before rebalance \n    port_value[i+1] = shares[i]*s[i+1] + cash[i]*exp(r*dt) + z*calls[i+1]\n    \n    # rebalance (self-finacing) to delta neutral\n    shares[i+1] = deltas[i+1]*(-z)\n    cash[i+1] = cash[i]*exp(r*dt) + (shares[i] - shares[i+1])*s[i+1]\n    \n# display the result\ndf = pd.DataFrame(np.array([port_value, s, calls, shares, cash]).T)\ndf.columns = ['portfolio value', 'stock price', 'call price', 'shares', 'cash']\ndf\n\n\n\n\n\n\n\n\nportfolio value\nstock price\ncall price\nshares\ncash\n\n\n\n\n0\n0.000000\n10.000000\n0.149623\n200.758640\n-1792.110966\n\n\n1\n-17.427621\n9.635278\n0.159682\n209.518291\n-1876.512634\n\n\n2\n-19.743216\n9.879387\n0.213143\n258.605690\n-2361.466038\n\n\n3\n-19.518629\n9.705907\n0.168055\n219.414354\n-1981.078588\n\n\n4\n-22.058641\n9.471260\n0.119110\n171.310927\n-1525.478513\n\n\n5\n-19.713859\n9.402198\n0.104935\n156.570553\n-1386.886597\n\n\n6\n-17.408770\n9.488928\n0.116209\n169.851260\n-1512.906275\n\n\n7\n-16.502103\n9.649344\n0.142549\n198.540336\n-1789.737038\n\n\n8\n-20.191266\n9.919250\n0.199826\n254.445814\n-2344.277469\n\n\n9\n-17.655077\n9.814348\n0.170597\n228.536144\n-2089.990953\n\n\n10\n-14.350273\n9.892156\n0.185074\n243.542111\n-2238.432316\n\n\n11\n-19.861466\n9.608748\n0.121564\n180.343419\n-1631.171994\n\n\n12\n-17.577465\n9.520467\n0.103359\n160.636633\n-1443.554186\n\n\n13\n-18.422900\n9.326691\n0.073077\n124.001764\n-1101.872064\n\n\n14\n-16.400700\n9.262272\n0.063067\n111.249547\n-983.757563\n\n\n15\n-22.801306\n9.601059\n0.107157\n168.003464\n-1528.655258\n\n\n16\n-21.978980\n9.455665\n0.081908\n137.864542\n-1243.671696\n\n\n17\n-19.693260\n9.550534\n0.092702\n152.487415\n-1383.327940\n\n\n18\n-16.696205\n9.529597\n0.086512\n145.614638\n-1317.833141\n\n\n19\n-19.278934\n9.292716\n0.054601\n102.567537\n-917.808672\n\n\n20\n-19.395107\n9.125778\n0.037595\n76.731246\n-682.032422\n\n\n21\n-19.796585\n9.329379\n0.053619\n102.524881\n-922.671030\n\n\n22\n-24.706482\n9.024074\n0.027228\n59.922954\n-538.228081\n\n\n23\n-24.123633\n8.906827\n0.019619\n46.107735\n-415.178309\n\n\n24\n-22.873051\n8.905059\n0.018287\n43.827660\n-394.874107\n\n\n25\n-22.210152\n9.041282\n0.023594\n54.518863\n-491.536294\n\n\n26\n-21.396242\n9.178402\n0.030256\n67.351813\n-609.322271\n\n\n27\n-22.194932\n8.983764\n0.017945\n44.199816\n-401.330196\n\n\n28\n-21.353905\n8.904764\n0.013613\n35.390911\n-322.888977\n\n\n29\n-20.774534\n8.812108\n0.009754\n26.948927\n-248.497305\n\n\n30\n-19.901331\n8.859088\n0.010147\n28.120210\n-258.873804"
  },
  {
    "objectID": "NSD_Lec03-BlackMertonScholes-1_Summer2025.html#dynamic-hedge-in-practice",
    "href": "NSD_Lec03-BlackMertonScholes-1_Summer2025.html#dynamic-hedge-in-practice",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "Dynamic hedge in practice",
    "text": "Dynamic hedge in practice\n\nContinuous trading in practice is unrealistic.\nThe tradeoff between frequency of rebalancing and replication of derivative\nImperfect hedge, risk penalty\nTransaction cost, market order or limit order, etc"
  },
  {
    "objectID": "NSD_Lec03-BlackMertonScholes-1_Summer2025.html#deep-hedging",
    "href": "NSD_Lec03-BlackMertonScholes-1_Summer2025.html#deep-hedging",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "Deep hedging",
    "text": "Deep hedging\nResearch works on hedging problem that resort to reinforcement learning techniques include\n\nHalperin, QLBS: Q-Learner in the Black-Scholes(-Merton) Worlds\nBuehler, Gonon, Teichmann, and Wood, Deep hedging\nCao, Chen, Hull, and Poulos, Deep hedging of derivatives using reinforcement learning\nKolm and Ritter, Dynamic replication and hedging: a reinforcement learning approach"
  },
  {
    "objectID": "NSD_Lec03-BlackMertonScholes-1_Summer2025.html#deep-hedging-in-a-nutshell",
    "href": "NSD_Lec03-BlackMertonScholes-1_Summer2025.html#deep-hedging-in-a-nutshell",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "Deep hedging in a nutshell",
    "text": "Deep hedging in a nutshell\nThe key idea behind deep hedging in the aforementioned works is to formulate the hedging problem as a stochastic control problem with certain objective functional, then solve the resulting control problem by the techniques introduced in reinforcement learning.\nLet’s take the work by Cao, Chen, Hull, and Poulos as an example."
  },
  {
    "objectID": "NSD_Lec03-BlackMertonScholes-1_Summer2025.html#notations",
    "href": "NSD_Lec03-BlackMertonScholes-1_Summer2025.html#notations",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "Notations",
    "text": "Notations\n\n\\(i\\): time, running from \\(0\\) to \\(n\\)\n\\(C_i\\): value of the call/derivative at the beginning of the time \\(i\\)\n\\(S_i\\): price of the underlying at the beginning of the time \\(i\\)\n\\(H_i\\): holdings of the underlying between time \\(i\\) and \\(i+1\\).\n\\(\\kappa\\): proportional transaction cost\n\\(R_i\\): running reward gained at time \\(i\\)"
  },
  {
    "objectID": "NSD_Lec03-BlackMertonScholes-1_Summer2025.html#settings-in-cao-chen-hull-poulos",
    "href": "NSD_Lec03-BlackMertonScholes-1_Summer2025.html#settings-in-cao-chen-hull-poulos",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "Settings in Cao-Chen-Hull-Poulos",
    "text": "Settings in Cao-Chen-Hull-Poulos\nCao-Chen-Hull-Poulos formulate the hedging problem as follows.\n\na trader is hedging a short position in a call option\nhedging portfolio consisting of shares in the underlying, no cash component?\nthe trader re-balances his position at time intervals of length \\(\\Delta t\\) and is subject to trading costs\nThe life of the option is \\(n\\).\nThe cost of a trade in the underlying asset is proportional to the value of what is being bought or sold\nThe state at time \\(i\\) is defined by three parameters:\n\nThe holding \\(H_{i-1}\\) of the asset during the previous time period; i.e., from time \\(i-1\\) to time \\(i\\)\nThe asset price \\(S_i\\) at time \\(i\\)\nThe time to maturity \\((n-i)\\)\n\nThe action/control \\(H_i\\) at time \\(i\\) is the amount of the asset to be held for the next period, i.e., from time \\(i\\) to time \\(i+1\\).\nRebalance is done after observing the price change."
  },
  {
    "objectID": "NSD_Lec03-BlackMertonScholes-1_Summer2025.html#two-alternative-formulations",
    "href": "NSD_Lec03-BlackMertonScholes-1_Summer2025.html#two-alternative-formulations",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "Two alternative formulations",
    "text": "Two alternative formulations\n\nThere are two alternative formulations for the hedging problem:\n\nthe accounting P&L formulation\nthe cash flow formulation.\n\nFor ease of exposition, no discounting is assumed in the control problem, i.e., \\(\\gamma=1\\)"
  },
  {
    "objectID": "NSD_Lec03-BlackMertonScholes-1_Summer2025.html#accounting-pl-formulation",
    "href": "NSD_Lec03-BlackMertonScholes-1_Summer2025.html#accounting-pl-formulation",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "Accounting P&L formulation",
    "text": "Accounting P&L formulation\nFor \\(1 \\leq i \\leq n\\), define the running reward gained at time \\(i\\) as\n\\[\\begin{equation}\n\\begin{aligned}\n  R_i &= -C_i + C_{i-1} + H_{i-1} (S_i - S_{i-1}) - \\kappa |S_i (H_i - H_{i-1})| \\\\\n      &= -\\Delta C_i + \\underbrace{H_{i-1} \\Delta S_i}_{\\text{marked to market}} - \\underbrace{\\kappa |S_i \\Delta H_i|}_{\\text{transaction cost}}.\n\\end{aligned}\n\\end{equation}\\]\nNote that this formulation is consistent with the self-financing condition with transaction cost that was discussed previously. To set up the hedging initially and liquidate the position at expiry of option, we add to the (undiscounted) cumulative rewards\n\ninitial reward: \\(-\\kappa|S_0 H_0|\\)\nterminal reward: \\(-\\kappa|S_n H_n|\\)\n\nThus, the performance criterion \\(Y^A\\) for a given hedging strategy \\((H_0, \\cdots, H_n)\\) reads\n\\[\\begin{equation}\n\\begin{aligned}\n  Y^A &= -\\kappa |S_0 H_0| + \\sum_{i=1}^n R_i - \\kappa |S_n H_n| \\\\\n      &= -\\kappa |S_0 H_0| + C_0 - C_n + \\sum_{i=1}^n H_{i-1} \\Delta S_i - \\kappa \\sum_{i=1}^n |S_i \\Delta H_i| - \\kappa |S_n H_n|.\n\\end{aligned}\n\\end{equation}\\]"
  },
  {
    "objectID": "NSD_Lec03-BlackMertonScholes-1_Summer2025.html#cashflow-formulation",
    "href": "NSD_Lec03-BlackMertonScholes-1_Summer2025.html#cashflow-formulation",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "Cashflow formulation",
    "text": "Cashflow formulation\nIn this formulation, for \\(1 \\leq i \\leq n\\), the running reward gained at time \\(i\\) is defined by\n\\[\nR_i = S_i(H_{i-1} - H_i) - \\kappa |S_i(H_i - H_{i-1})|\n= -S_i \\Delta H_i - \\kappa |S_i \\Delta H_i|\n\\]\nwith - initial cost for setting up a position: \\(-S_0H_0 - \\kappa|S_0 H_0|\\) - terminal cost for liquidate the position and payoff to call: \\(S_nH_n - \\kappa|S_n H_n| - C_n\\).\nThus, the performance criterion \\(Y^C\\) for a given hedging strategy \\((H_0, \\cdots, H_n)\\) reads\n\\[\\begin{equation}\n\\begin{aligned}\n  Y^C &= -S_0 H_0 - \\kappa |S_0 H_0| + \\sum_{i=1}^n R_i + S_n H_n - \\kappa |S_n H_n| - C_n \\\\\n      &= -S_0 H_0 - \\kappa |S_0 H_0| - \\sum_{i=1}^n S_i \\Delta H_i - \\kappa \\sum_{i=1}^n |S_i \\Delta H_i| + S_n H_n - \\kappa |S_n H_n| - C_n.\n\\end{aligned}\n\\end{equation}\\]"
  },
  {
    "objectID": "NSD_Lec03-BlackMertonScholes-1_Summer2025.html#accounting-pl-vs-cashflow",
    "href": "NSD_Lec03-BlackMertonScholes-1_Summer2025.html#accounting-pl-vs-cashflow",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "Accounting P&L vs cashflow",
    "text": "Accounting P&L vs cashflow\nRecall that\n\\[\\begin{equation}\n\\begin{aligned}\n  Y^A &= -\\kappa |S_0 H_0| + C_0 - C_n + \\sum_{i=1}^n H_{i-1} \\Delta S_i - \\kappa \\sum_{i=1}^n |S_i \\Delta H_i| - \\kappa |S_n H_n| \\\\\n      &= -\\kappa |S_0 H_0| + C_0 - C_n + H_n S_n - H_0 S_0 - \\sum_{i=1}^n S_i \\Delta H_i - \\kappa \\sum_{i=1}^n |S_i \\Delta H_i| - \\kappa |S_n H_n|.\n\\end{aligned}\n\\end{equation}\\]\nwhere in the last equality we applied the following summation by parts formula\n\\[\\begin{equation}\n\\sum_{i=1}^n H_{i-1} \\Delta S_i = H_n S_n - H_0 S_0 - \\sum_{i=1}^n S_i \\Delta H_i.\n\\end{equation}\\]\nIt follows that\n\\[\\begin{equation}\nY^A - Y^C = C_0.\n\\end{equation}\\]\nThe two formulations are basically the same."
  },
  {
    "objectID": "NSD_Lec03-BlackMertonScholes-1_Summer2025.html#objective-functional-and-resulting-control-problem",
    "href": "NSD_Lec03-BlackMertonScholes-1_Summer2025.html#objective-functional-and-resulting-control-problem",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "Objective functional and resulting control problem",
    "text": "Objective functional and resulting control problem\nObjective functional for the performance criterion \\(Y\\) is given by its expectation penalized by a risk measure. Namely,\n\\[\n\\Eof{Y} - \\lambda \\rho(Y),\n\\]\nwhere \\(\\rho\\) is certain prespecified risk measure. Hence, the hedging problem can be recast as the following stochastic control problem\n\\[\n\\max_{(H_0, \\cdots, H_n)} \\Eof{Y} - \\lambda \\rho(Y).\n\\]\nFrom this point on, reinforcement learning techniques are then applied to solve the above control problem.\n\nNote\n\nIn the original Cao-Chen-Hull-Poulos paper, the authors chose to penalize the expected reward by standard deviation. However, from control theory point of view, penalizing expected reward by variance/standard deviation will induce (unnecessary?) difficulty due to time inconsistency.\nIn the Buehler et al paper, the authors utilized the expected shortfall or conditional value-at-risk as the risk measure."
  },
  {
    "objectID": "NSD_Lec03-BlackMertonScholes-1_Summer2025.html#implementation-of-deep-hedging-in-tensorflow",
    "href": "NSD_Lec03-BlackMertonScholes-1_Summer2025.html#implementation-of-deep-hedging-in-tensorflow",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "Implementation of Deep hedging in Tensorflow",
    "text": "Implementation of Deep hedging in Tensorflow\nCourtsey: Laura He and Tony Xie, Baruch MFE 2020"
  },
  {
    "objectID": "NSD_Lec03-BlackMertonScholes-1_Summer2025.html#deep-hedging-implementation-with-ddpg-algorithm",
    "href": "NSD_Lec03-BlackMertonScholes-1_Summer2025.html#deep-hedging-implementation-with-ddpg-algorithm",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "Deep-hedging implementation with DDPG Algorithm",
    "text": "Deep-hedging implementation with DDPG Algorithm\nStep 1 Initialize neural network of \\(Q_1(s,a|\\theta^{Q_1}), Q_2(s,a|\\theta^{Q_2})\\) and policy function \\(\\mu(s|\\theta^\\mu)\\). Set target networks \\(Q_1' \\leftarrow Q_1,Q_2' \\leftarrow Q_2,\\mu' \\leftarrow \\mu\\). Create replay buffer \\(R\\).\nStep 2 Begin loop:\nfor episode \\(= 1\\) to n_path:\nGenerate random process \\({N_i}, i = 0, 1, ..., m\\) for action exploration.  Get initial state: \\(s_0 = [S_0\\)(stock price), \\(V_0\\)(option price), \\(H_{-1} = 0\\)(holding), \\(\\tau_0 = T = m\\, dt\\)(time to maturity)\\(]\\).\nfor \\(i = 0\\) to \\(m\\) (\\(m\\) time intervals):\nStep 2.1 Calculate action: \\(a_i = (1-\\epsilon_i)\\mu(s_i|\\theta^\\mu) + \\epsilon_i N_i,\\,\\, s_i = [S_i, V_i, H_{i-1}, \\tau_i = (m-i)dt]\\)  Step 2.2 Execute \\(a_i\\). Get \\(r_i = -(V_{i+1} - V_i) + H_i(S_{i+1} - S_i) - \\kappa |S_ia_i|,\\,\\, 0\\leqslant i&lt;m\\)  \\(\\hspace{4.2 cm} r_m = - \\kappa|S_mH_{m-1}|\\)  Step 2.3 Observe new state: \\(s_{i+1} = [S_{i+1}, V_{i+1}, H_i = H_{i-1}+a_i, \\tau_{i+1} = (m-i-1)dt]\\)  Step 2.4 Store \\((s_i, a_i, r_i, s_{i+1})\\) in the replay buffer \\(R\\).  Step 2.5 Sample \\(J\\) transitions from \\(R\\), mark as \\((s_j, a_j, r_j, s_{j+1}), \\,\\, j = 1 \\sim N/ J?\\)  \\(\\hspace{1.6 cm}y_j^{(1)} = r_j + \\gamma Q_1'(s_{i+1}, \\mu'(s_{i+1}|\\theta^{\\mu'})|\\theta^{Q'})\\)\n$y_j^{(2)} = r_j^2 + ^2 Q_2’(s_{i+1}, ‘(s_{i+1}|{’})|{Q’}) + 2 r_j Q_1’(s_{i+1}, ‘(s_{i+1}|{’})|{Q’}) $\n\\(\\hspace{1.4 cm}\\) Update \\(Q_{1,2}\\): \\(Q_{1,2} = \\underset{Q_{1,2}}{\\mathrm{argmin}}\\left\\{\\frac{1}{J}\\sum_j\\left(y_j^{(1,2)} - Q_{1,2}(s_j,a_j|\\theta^{Q_{1,2}})\\right)^2\\right\\}\\)  \\(\\hspace{1.4 cm}\\) Update \\(\\mu\\) using gradient descent: \\(\\nabla_{\\theta^{\\mu}}G = \\frac{1}{J}\\sum_j\\nabla_aF(s_j, a_j|\\theta^{Q_{1,2}})\\nabla_{\\theta^{\\mu}}\\mu(s_j|\\theta^{\\mu}),\\,\\, \\theta^\\mu = \\theta^\\mu - \\nabla_{\\theta^\\mu}G \\times \\text{step}\\)\nStep 2.6 Update the target networks: \\(\\theta^{Q'_{1,2}} \\leftarrow \\tau\\theta^{Q_{1,2}} + (1-\\tau)\\theta^{Q'_{1,2}}, \\,\\,\\theta^{\\mu'} \\leftarrow \\tau\\theta^\\mu + (1-\\tau)\\theta^{\\mu'}\\)\n\npip show DDPG\n\nNote: you may need to restart the kernel to use updated packages.\n\n\nWARNING: Package(s) not found: DDPG\n\n\n\n# import DDPG and other related packages\n\nimport numpy as np\nfrom DDPG.world import World\nimport tensorflow as tf\nfrom DDPG.blackscholesgenerator import GenerateBSPath, BSCall\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport seaborn as sns"
  },
  {
    "objectID": "NSD_Lec03-BlackMertonScholes-1_Summer2025.html#performance-of-deep-hedging-vs-delta-hedging",
    "href": "NSD_Lec03-BlackMertonScholes-1_Summer2025.html#performance-of-deep-hedging-vs-delta-hedging",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "Performance of deep hedging vs delta hedging",
    "text": "Performance of deep hedging vs delta hedging\n\n# python function to implement the trained model \ndef DDPG(n_path=5000, m=4, T=1/12, r=0, q=0, sigma=0.2, S0=100, K=100, model_path=\"\"):\n    stock_price, call_price, call_delta = GenerateBSPath(n_path=n_path, \\\n                m=m, T=T, r=r, q=q, sigma=sigma, S0=S0, K=K)\n        \n    V0 = call_price[0,0]\n    initial_state = np.array([S0, V0, 0, T])\n    state_size, action_size = 4, 1\n\n    world = World(state_size, action_size, initial_state, dt=T/m)\n    # load-in saved (trained) model \n    # actor_model = tf.keras.models.load_model(f'{model_path}/Actor_Model', compile=False)\n    actor_model = tf.keras.layers.TFSMLayer(\n        f'{model_path}/Actor_Model', \n        call_endpoint='serving_default'\n    )\n\n    actions_model = np.zeros((n_path, m))\n    rewards = np.zeros(n_path)\n\n    for episode in range(n_path):\n\n        if episode % 2000 == 0:\n            print(episode)\n\n        world.initialize()\n\n        for i in range(m):\n            state = world.get_state()\n            output = actor_model(np.array([state])) # 假设 output 是字典\n            first_value = next(iter(output.values())).numpy()[0, 0]  # 提取第一个值并转为标量\n            actions_model[episode, i] = first_value\n            # actor_model(np.array([state]))[0,0]\n            next_state, reward, done = world.act(actions_model[episode, i], (stock_price[episode, i+1], call_price[episode, i+1]))\n            rewards[episode] += reward \n\n        state = world.get_state()\n        rewards[episode] += world.act(0, (0,0))[1]\n\n#    print(actions_model)\n    \n    positions = call_delta[:,:m]\n    actions = np.hstack((call_delta[:,0].reshape(n_path,1), np.diff(call_delta[:,:m], axis = 1)))\n    payoff = positions*np.diff(stock_price, axis=1) - np.diff(call_price, axis=1) - np.abs(actions*stock_price[:,:m])*0.01 \n    payoff = np.sum(payoff, axis=1)\n    payoff -= np.abs(call_delta[:,m]*stock_price[:,m])*0.01\n        \n    payoff_zero = - np.diff(call_price, axis = 1) \n    payoff_zero = np.sum(payoff_zero, axis = 1)\n    \n    hedging_cost_mean = np.array([-rewards.mean(), -payoff.mean(), -payoff_zero.mean()])\n    hedging_cost_std = np.array([rewards.std(), payoff.std(), payoff_zero.std()])\n    obj_func = hedging_cost_mean + 1.5*hedging_cost_std\n    \n    method_name = [\"DDPG\", \"Delta\", \"No Hedge\"]\n    hedging_cost_mean = np.array([-rewards.mean(), -payoff.mean(), -payoff_zero.mean()])\n    hedging_cost_std = np.array([rewards.std(), payoff.std(), payoff_zero.std()])\n    obj_func = hedging_cost_mean + 1.5*hedging_cost_std\n    \n    mean_in_price = 100 * hedging_cost_mean / V0\n    std_in_price = 100 * hedging_cost_std / V0\n    obj_func_in_price = mean_in_price + 1.5*std_in_price\n    \n    result = pd.DataFrame({'Name': method_name,\n                           'Mean': hedging_cost_mean,\n                           'STD': hedging_cost_std, \n                           'Obj Func': obj_func, #\\\n                           'Mean in Option Price(%)': mean_in_price, \n                           'STD in Option Price(%)': std_in_price, #\\\n                           'Obj Func in Option Price(%)': obj_func_in_price})\n    \n    print(f\"----------- DDPG Result: {m} hedges in {int(T*12)} month. -----------\")\n        \n    print(result)\n    \n    plt.figure(figsize=(8,6))\n    sns.histplot(rewards, label='DDPG', kde=True, stat='density', element='step')\n    sns.histplot(payoff, kde=True, label='Delta', stat='density', color='orange', element='step')\n    plt.legend()\n    plt.show()\n    \n    return actor_model\n\n\n# function for plotting optimal policy \nfrom mpl_toolkits.mplot3d import Axes3D\n\ndef plotAction(curr_model):\n    \n    TT = np.arange(0, 1, 0.05)\n    SS = np.arange(80, 120, 0.5)\n    Y, X = np.meshgrid(TT, SS)\n    Z_DDPG = np.zeros((SS.shape[0], TT.shape[0]))\n    #Z_BS = np.zeros((SS.shape[0], TT.shape[0]))\n\n    for i in range(SS.shape[0]):\n        for j in range(TT.shape[0]):\n            BS_model = BSCall(T=TT[j], sigma=sigma, S0=SS[i])\n            output = curr_model(np.array([[SS[i],BS_model[0],0,TT[j]]]))\n            Z_DDPG[i,j] = next(iter(output.values())).numpy()[0][0]\n            #Z_BS[i,j] = BS_model[1]\n        \n    V0 = BSCall(T=T, sigma=sigma, S0=S0)[0]\n    BS_action_pos = [next(iter(curr_model(np.array([[S0, V0, _pos, T]])).values())).numpy()[0][0] for _pos in np.arange(-1,1,0.05)]\n    \n    # %matplotlib notebook\n    fig = plt.figure(figsize=(16,6))  \n    ax3 = fig.add_subplot(1, 2, 1, projection='3d')\n    ax3.plot_surface(X, Y, Z_DDPG)\n    # ax3.plot_surface(X,Y,Z_BS)\n    plt.title(\"Action vs. Stock price & Time to maturity\")\n    plt.xlabel(\"Stock price\")\n    plt.ylabel(\"Time to maturity\")\n    \n    ax2 = fig.add_subplot(1, 2, 2)\n    ax2.plot(np.arange(-1, 1, 0.05), BS_action_pos)\n    plt.title(\"Action vs. Position\")\n    plt.xlabel(\"Position\")\n    plt.show();"
  },
  {
    "objectID": "NSD_Lec03-BlackMertonScholes-1_Summer2025.html#one-month-option-weekly-hedging",
    "href": "NSD_Lec03-BlackMertonScholes-1_Summer2025.html#one-month-option-weekly-hedging",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "One-month option, weekly hedging",
    "text": "One-month option, weekly hedging\n\n%%time\n# model paramters\nr, q, sigma, S0, K = 0, 0, 0.2, 100, 100\n\n# simulation parameters\n# option expires in a month, hedging weekly\nT, m, n_path = 1/12, 4, 5_000\n\nmodel_path = \"DDPG/trained_models/1m/weekly\"\n\n# set random seed for reproducing the result\nnp.random.seed(9999)\n\nweekly = DDPG(n_path=n_path, m=m, T=T, r=r, q=q, sigma=sigma, S0=S0, K=K, model_path=model_path)\n\n0\n2000\n4000\n----------- DDPG Result: 4 hedges in 1 month. -----------\n       Name      Mean       STD  Obj Func  Mean in Option Price(%)  \\\n0      DDPG  1.135191  2.199476  4.434405                49.292365   \n1     Delta  1.543443  1.172043  3.301507                67.019524   \n2  No Hedge  0.053613  3.528923  5.346998                 2.327991   \n\n   STD in Option Price(%)  Obj Func in Option Price(%)  \n0               95.505890                   192.551201  \n1               50.892563                   143.358369  \n2              153.233282                   232.177914  \n\n\n\n\n\n\n\n\n\nCPU times: total: 2.83 s\nWall time: 18.5 s"
  },
  {
    "objectID": "NSD_Lec03-BlackMertonScholes-1_Summer2025.html#what-does-the-optimal-action-look-like",
    "href": "NSD_Lec03-BlackMertonScholes-1_Summer2025.html#what-does-the-optimal-action-look-like",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "What does the optimal action look like?",
    "text": "What does the optimal action look like?\n\nplotAction(weekly)"
  },
  {
    "objectID": "NSD_Lec03-BlackMertonScholes-1_Summer2025.html#one-month-option-tridaily-hedging",
    "href": "NSD_Lec03-BlackMertonScholes-1_Summer2025.html#one-month-option-tridaily-hedging",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "One-month option, tridaily hedging",
    "text": "One-month option, tridaily hedging\n\n%%time\n# one month option, tridaily hedging\nT, m = 1/12, 10\nmodel_path = \"DDPG/trained_models/1m/3-day\"\ntridaily = DDPG(n_path=n_path, m=m, T=T, r=r, q=q, sigma=sigma, S0=S0, K=K, model_path=model_path)\n\n0\n2000\n4000\n----------- DDPG Result: 10 hedges in 1 month. -----------\n       Name      Mean       STD  Obj Func  Mean in Option Price(%)  \\\n0      DDPG  1.798405  2.092016  4.936429                78.090545   \n1     Delta  1.957786  0.940487  3.368517                85.011175   \n2  No Hedge  0.017840  3.497339  5.263849                 0.774652   \n\n   STD in Option Price(%)  Obj Func in Option Price(%)  \n0               90.839724                   214.350131  \n1               40.837944                   146.268091  \n2              151.861840                   228.567411  \n\n\n\n\n\n\n\n\n\nCPU times: total: 7.08 s\nWall time: 50 s\n\n\n\n# plot tridaily action function \nplotAction(tridaily)"
  },
  {
    "objectID": "NSD_Lec03-BlackMertonScholes-1_Summer2025.html#month-option-weekly-hedging",
    "href": "NSD_Lec03-BlackMertonScholes-1_Summer2025.html#month-option-weekly-hedging",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "3-month option, weekly hedging",
    "text": "3-month option, weekly hedging\n\n%%time\n# 3 months option, weekly hedging\nT, m = 3/12, 4\nmodel_path = \"DDPG/trained_models/3m/weekly\"\nweekly_3m = DDPG(n_path=n_path, m=m, T=T, r=r, q=q, sigma=sigma, S0=S0, K=K, model_path=model_path)\n\n0\n2000\n4000\n----------- DDPG Result: 4 hedges in 3 month. -----------\n       Name      Mean       STD  Obj Func  Mean in Option Price(%)  \\\n0      DDPG  0.857973  3.904091  6.714109                21.515145   \n1     Delta  1.474011  1.784586  4.150890                36.963365   \n2  No Hedge -0.124989  6.013195  8.894803                -3.134323   \n\n   STD in Option Price(%)  Obj Func in Option Price(%)  \n0               97.901820                   168.367874  \n1               44.751576                   104.090729  \n2              150.791253                   223.052557  \n\n\n\n\n\n\n\n\n\nCPU times: total: 4.3 s\nWall time: 19.9 s\n\n\n\nplotAction(weekly_3m)"
  },
  {
    "objectID": "NSD_Lec03-BlackMertonScholes-1_Summer2025.html#concluding-remarks-on-deep-hedging",
    "href": "NSD_Lec03-BlackMertonScholes-1_Summer2025.html#concluding-remarks-on-deep-hedging",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "Concluding remarks on deep hedging",
    "text": "Concluding remarks on deep hedging\n\nHedging with DDPG Algorithm can reduce the average hedging cost, however, it increases the variance of cost for the Black-Scholes model and probably also for stochastic volatility models.\nAs is mentioned in the original paper, the impact of trading costs (or transaction cost) is to under-hedge relative to delta hedging in some situations and over-hedge in other situations. By hedging short European call option position, we observe under-hedge relative to delta hedging.\nOne may be able to reduce the variance of hedging cost in the DDPG Algorithm by adding more paths for training. In the code, we used 5000 training paths for each model while renewing the model after each episode. However, using too many paths in the training stage may result in overfitting."
  },
  {
    "objectID": "NSD_Lec01-FinancialEngineering_Summer2025.html",
    "href": "NSD_Lec01-FinancialEngineering_Summer2025.html",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "",
    "text": "Tai-Ho Wang (王 太和)\n\n\\[\n\\newcommand{\\bea}{\\begin{eqnarray}}\n\\newcommand{\\eea}{\\end{eqnarray}}\n\\newcommand{\\supp}{\\mathrm{supp}}\n\\newcommand{\\F}{\\mathcal{F} }\n\\newcommand{\\cF}{\\mathcal{F} }\n\\newcommand{\\E}{\\mathbb{E} }\n\\newcommand{\\Eof}[1]{\\mathbb{E}\\left[ #1 \\right]}\n\\newcommand{\\Etof}[1]{\\mathbb{E}_t\\left[ #1 \\right]}\n\\def\\Cov{{ \\mbox{Cov} }}\n\\def\\Var{{ \\mbox{Var} }}\n\\newcommand{\\1}{\\mathbf{1} }\n\\newcommand{\\p}{\\partial}\n\\newcommand{\\PP}{\\mathbb{P} }\n\\newcommand{\\Pof}[1]{\\mathbb{P}\\left[ #1 \\right]}\n\\newcommand{\\QQ}{\\mathbb{Q} }\n\\newcommand{\\R}{\\mathbb{R} }\n\\newcommand{\\DD}{\\mathbb{D} }\n\\newcommand{\\HH}{\\mathbb{H} }\n\\newcommand{\\spn}{\\mathrm{span} }\n\\newcommand{\\cov}{\\mathrm{cov} }\n\\newcommand{\\HS}{\\mathcal{L}_{\\mathrm{HS}} }\n\\newcommand{\\Hess}{\\mathrm{Hess} }\n\\newcommand{\\trace}{\\mathrm{trace} }\n\\newcommand{\\LL}{\\mathcal{L} }\n\\newcommand{\\s}{\\mathcal{S} }\n\\newcommand{\\ee}{\\mathcal{E} }\n\\newcommand{\\ff}{\\mathcal{F} }\n\\newcommand{\\hh}{\\mathcal{H} }\n\\newcommand{\\bb}{\\mathcal{B} }\n\\newcommand{\\dd}{\\mathcal{D} }\n\\newcommand{\\g}{\\mathcal{G} }\n\\newcommand{\\half}{\\frac{1}{2} }\n\\newcommand{\\T}{\\mathcal{T} }\n\\newcommand{\\bit}{\\begin{itemize}}\n\\newcommand{\\eit}{\\end{itemize}}\n\\newcommand{\\beq}{\\begin{equation}}\n\\newcommand{\\eeq}{\\end{equation}}\n\\newcommand{\\tr}{\\mbox{tr}}\n\\]"
  },
  {
    "objectID": "NSD_Lec01-FinancialEngineering_Summer2025.html#lecture-1-financial-engineering-in-a-nutshell",
    "href": "NSD_Lec01-FinancialEngineering_Summer2025.html#lecture-1-financial-engineering-in-a-nutshell",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "",
    "text": "Tai-Ho Wang (王 太和)\n\n\\[\n\\newcommand{\\bea}{\\begin{eqnarray}}\n\\newcommand{\\eea}{\\end{eqnarray}}\n\\newcommand{\\supp}{\\mathrm{supp}}\n\\newcommand{\\F}{\\mathcal{F} }\n\\newcommand{\\cF}{\\mathcal{F} }\n\\newcommand{\\E}{\\mathbb{E} }\n\\newcommand{\\Eof}[1]{\\mathbb{E}\\left[ #1 \\right]}\n\\newcommand{\\Etof}[1]{\\mathbb{E}_t\\left[ #1 \\right]}\n\\def\\Cov{{ \\mbox{Cov} }}\n\\def\\Var{{ \\mbox{Var} }}\n\\newcommand{\\1}{\\mathbf{1} }\n\\newcommand{\\p}{\\partial}\n\\newcommand{\\PP}{\\mathbb{P} }\n\\newcommand{\\Pof}[1]{\\mathbb{P}\\left[ #1 \\right]}\n\\newcommand{\\QQ}{\\mathbb{Q} }\n\\newcommand{\\R}{\\mathbb{R} }\n\\newcommand{\\DD}{\\mathbb{D} }\n\\newcommand{\\HH}{\\mathbb{H} }\n\\newcommand{\\spn}{\\mathrm{span} }\n\\newcommand{\\cov}{\\mathrm{cov} }\n\\newcommand{\\HS}{\\mathcal{L}_{\\mathrm{HS}} }\n\\newcommand{\\Hess}{\\mathrm{Hess} }\n\\newcommand{\\trace}{\\mathrm{trace} }\n\\newcommand{\\LL}{\\mathcal{L} }\n\\newcommand{\\s}{\\mathcal{S} }\n\\newcommand{\\ee}{\\mathcal{E} }\n\\newcommand{\\ff}{\\mathcal{F} }\n\\newcommand{\\hh}{\\mathcal{H} }\n\\newcommand{\\bb}{\\mathcal{B} }\n\\newcommand{\\dd}{\\mathcal{D} }\n\\newcommand{\\g}{\\mathcal{G} }\n\\newcommand{\\half}{\\frac{1}{2} }\n\\newcommand{\\T}{\\mathcal{T} }\n\\newcommand{\\bit}{\\begin{itemize}}\n\\newcommand{\\eit}{\\end{itemize}}\n\\newcommand{\\beq}{\\begin{equation}}\n\\newcommand{\\eeq}{\\end{equation}}\n\\newcommand{\\tr}{\\mbox{tr}}\n\\]"
  },
  {
    "objectID": "NSD_Lec01-FinancialEngineering_Summer2025.html#coordinates",
    "href": "NSD_Lec01-FinancialEngineering_Summer2025.html#coordinates",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "Coordinates",
    "text": "Coordinates\n\nEmail: tai-ho.wang@baruch.cuny.edu\nWebpage: mfe.baruch.cuny.edu/tai-ho.wang"
  },
  {
    "objectID": "NSD_Lec01-FinancialEngineering_Summer2025.html#teaching-assistants",
    "href": "NSD_Lec01-FinancialEngineering_Summer2025.html#teaching-assistants",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "Teaching Assistants",
    "text": "Teaching Assistants\n丁宏骏\n\n北大计算机本科毕\nBaruch MFE 2025 incoming student\nEmail: dinghongjun@stu.pku.edu.cn\n\n李新宇\n\n北大数院直博\nEmail: xinyu911@stu.pku.edu.cn"
  },
  {
    "objectID": "NSD_Lec01-FinancialEngineering_Summer2025.html#aims-of-this-course",
    "href": "NSD_Lec01-FinancialEngineering_Summer2025.html#aims-of-this-course",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "Aims of this course",
    "text": "Aims of this course\n\nTo be familiar with the financial products and the modeling of their prices\nTo be familiar with well-known pricing models.\nTo be familiar with the principle of no arbitrage and its applications\nTo gain exposure to automated market making in decentralized exchange\nTo grasp theories of probability and statistics underpinning the models\nTo gain experiences in working with Jupyter notebook and programming in python"
  },
  {
    "objectID": "NSD_Lec01-FinancialEngineering_Summer2025.html#agenda",
    "href": "NSD_Lec01-FinancialEngineering_Summer2025.html#agenda",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "Agenda",
    "text": "Agenda\n\nFinancial market and financial product\nWhat is financial engineering?\n\\(\\mathbb{P}\\) quant v.s. \\(\\mathbb{Q}\\) quant\nTheory of pricing\n\nLaw of one price\nMonotonicity\nLinearity\n\nPrinciple of no arbitrage\nDecentralized finance (DeFi) and automated market making (AMM)\nBrief introduction to Jupyter notebook and programming in python"
  },
  {
    "objectID": "NSD_Lec01-FinancialEngineering_Summer2025.html#online-resources",
    "href": "NSD_Lec01-FinancialEngineering_Summer2025.html#online-resources",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "Online resources",
    "text": "Online resources\n\nInvestopedia\nWikipedia\nAdvanced Risk and Portfolio Management\n\n \n\nFinancial Markets and Financial Productions"
  },
  {
    "objectID": "NSD_Lec01-FinancialEngineering_Summer2025.html#financial-market",
    "href": "NSD_Lec01-FinancialEngineering_Summer2025.html#financial-market",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "Financial market",
    "text": "Financial market\nQuotes from Investopedia:\n\nA financial market is a broad term describing any marketplace where buyers and sellers participate in the trade of assets such as equities, bonds, currencies and derivatives. Financial markets are typically defined by having transparent pricing, basic regulations on trading, costs and fees, and market forces determining the prices of securities that trade.\n\n注:\n\nequities: 股票\nbonds: 债券\ncurrencies: 货币\nderivatives: 衍生品\n\nTypes of financial markets and their roles\n\nCaptial market\n\nbond market\nequity market\n\nDerivative market\nForEx (foreign exchange) and interbank market\nPrimary vs secondary market\n\nA primary market issues new securities on an exchange.\nThe secondary market is where investors purchase securities or assets from other investors, rather than from issuing companies themselves.\n\nOTC (over-the-counter) market\nThird and fourth market\nDecentralized Exchanges (DeExs)\n\nFor more details, visit Types of Financial Markets and their roles at Investopedia.\n注:\n\n一级市场, 又称发行市场, 初级市场 (Primary Market) 是处理新发行证券的金融市场, 筹集资金的公司, 政府或公共部门通过发行新的股票和债券来进行融资.\n二级市场 (Secondary Market) 是买卖已经上市公司股票的资本市场. 二级市场可为金融商品的最初投资者提供资金的流动性. 一级市场和二级市场通过证券交易所进行联系.\n股票交易属于场内交易, 也就是交易所交易, 因为所有交易是发生在固定的证券交易所, 有固定的交易时间和合约标准.\n然而, 还有另一个系统, 这就是场外交易市场, 它的交易是由“经纪商” (称为做市商) 促成的, 他们提供金融产品的买卖价格, 有效地确定资产的价格. 现在已经基本上不存在了.\n第三市场是指原来在证交所上市的股票移到以场外进行交易而形成的市场.\n第四市场指许多机构大投资者, 进行上市股票和其他证券的交易, 完全撇开经纪商和交易所, 直接与对方联系, 采用这种方式进行证券交易, 形成了第四市场.\n\nWe will only cover the equity market and the liquidity pools in DeExs."
  },
  {
    "objectID": "NSD_Lec01-FinancialEngineering_Summer2025.html#financial-products",
    "href": "NSD_Lec01-FinancialEngineering_Summer2025.html#financial-products",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "Financial products",
    "text": "Financial products\n\nPrimary or underlying\n\nEquity\nFixed income\nCommodity\nCredit\nCryptocurrency or token\n\nSecondary or derivatives\n\nForward (远期合约) and futures (期货)\nOptions (期权)\nSwaps (互换合约)\n\n\n注:\n\n远期合约: 约定在未来某一特定日期以今天商定的价格买入或卖出某种资产.\n期货: 约定在未来某一特定日期以今天商定的价格买入或卖出某种资产, 但与远期合约不同的是, 期货合约是标准化的, 在交易所交易.\n期权给予持有者权利而非义务, 在未来某个时间以预先确定的价格购买 (看涨期权, Call Option) 或出售 (看跌期权, Put Option) 一定数量的资产.\n期权持有人支付一笔期权费 (Premium) 给期权卖方, 以换取这种选择权.\n如果市场价格不利于期权持有人, 则可以选择不行使期权, 最大损失为已支付的期权费.\n互换是一种协议, 其中两方同意在未来的一段时间内交换一系列现金流.\n\n \n\nFinancial Engineering and Quantitative Finance"
  },
  {
    "objectID": "NSD_Lec01-FinancialEngineering_Summer2025.html#what-is-financial-engineering",
    "href": "NSD_Lec01-FinancialEngineering_Summer2025.html#what-is-financial-engineering",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "What is financial engineering?",
    "text": "What is financial engineering?\nAccording to this article in the website of International Association for Quantitative Finance (IAQF) (used to be named as IAFE), financial engineering is\n\nthe application of mathematical methods to the solution of problems in finance\nalso known as financial mathematics, mathematical finance, and computational finance\n\nTherefore,\n\nFinancial engineering draws on tools from applied mathematics, computer science, statistics, and economic theory.\nInvestment banks, commercial banks, hedge funds, insurance companies, corporate treasuries, and regulatory agencies employ financial engineers.\nThese businesses apply the methods of financial engineering to problems such as new product development, derivative securities valuation, portfolio structuring, risk management, and scenario simulation."
  },
  {
    "objectID": "NSD_Lec01-FinancialEngineering_Summer2025.html#what-is-financial-engineering-for",
    "href": "NSD_Lec01-FinancialEngineering_Summer2025.html#what-is-financial-engineering-for",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "What is financial engineering for?",
    "text": "What is financial engineering for?\n\nDerivative pricing\nPortfolio construction\nRisk management\nQuantitative trading\nMarket making and liquidity provision\nOrder implementation\n\nWe shall mostly focus on the pricing of derivatives based on the principle of no arbitrage.\nAs pricing is concerned, in financial engineering we usually consider the following types of problems:\n\ndirect problem: under a given model for the underlying, calculate the prices of its derivatives\ninverse problem: for a given set of prices of liquidly derivatives, determine the parameters or even a model that generates the observed market prices."
  },
  {
    "objectID": "NSD_Lec01-FinancialEngineering_Summer2025.html#what-skills-are-required-to-be-a-financial-engineer",
    "href": "NSD_Lec01-FinancialEngineering_Summer2025.html#what-skills-are-required-to-be-a-financial-engineer",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "What skills are required to be a financial engineer?",
    "text": "What skills are required to be a financial engineer?\nQuantitative finance is an interdisciplinary field, it requires hard skills in\n\nMath: calculus, linear algebra, probability, stochastic process, differential equation, optimization, etc\nFinance: derivative pricing theory, modern portfolio theory, market microstructure models\nStatistics: regression and classification, factor analysis, time series analysis\nProgramming: R, Python, C++, Matlab, etc\n\nNowadays also requires\n\nmachine learning techniques\nsentiment analysis"
  },
  {
    "objectID": "NSD_Lec01-FinancialEngineering_Summer2025.html#quantitative-analyst---quant",
    "href": "NSD_Lec01-FinancialEngineering_Summer2025.html#quantitative-analyst---quant",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "Quantitative analyst - Quant",
    "text": "Quantitative analyst - Quant\nExcerpt from Quants: The Rocket Scientists of Wall Street in Investopedia,\n\nAs financial securities become increasingly complex, demand has grown steadily for people who not only understand the complex mathematical models that price these securities, but who are able to enhance them to generate profits and reduce risk. These individuals are known as quantitative analysts, or simply “quants.”\n\nQuantitative analysts\n\ndesign and implement complex models that allow financial firms to price and trade securities\nfront desk quants work directly with traders, providing them with pricing or trading tools\nback office quants validate the models, conduct research and create new strategies\npositions are found almost exclusively in major financial centers with trading operations"
  },
  {
    "objectID": "NSD_Lec01-FinancialEngineering_Summer2025.html#mathbbp-quant-v.s.-mathbbq-quant",
    "href": "NSD_Lec01-FinancialEngineering_Summer2025.html#mathbbp-quant-v.s.-mathbbq-quant",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "\\(\\mathbb{P}\\) quant v.s. \\(\\mathbb{Q}\\) quant",
    "text": "\\(\\mathbb{P}\\) quant v.s. \\(\\mathbb{Q}\\) quant\nQuants are briefly categorized as \\(\\mathbb{P}\\) quants and \\(\\mathbb{Q}\\) quants.\n\n\\(\\mathbb{P}\\) refers to the physical measure under which the financial assets presumably evolves.\n\\(\\mathbb{Q}\\) refers to the risk neutral measure for pricing under the principle of no arbitrage.\n\nThe mentality behind \\(\\mathbb P\\) quant and the buy side is\n\nRegard the market as a whole, process historical data then forecast price movements\nConstruct portfolio or investment strategy based on performance measures\nDecide the horizon of holding the portfolio\nRisk management\n\nThe mentality behind \\(\\mathbb Q\\) quant and the sell side is\n\nConstruct model that could possibly explain the market\nCalibrate parameters of model to market data\nApply the calibrated model to price new derivatives\nHedging\n\n\nNote\n\nIn this course, we shall cover topics on both sides, though not evenly.\nPlease refer to this link in ARPM.co for more details on the interplay between \\(\\mathbb P\\) quants and \\(\\mathbb Q\\) quants.\n\\(\\PP\\) quant (Physical Probability Measure Quantitative Analyst, 物理测度下的量化分析) 关注的是资产在现实世界概率测度 (记作 \\(\\PP\\)) 下的行为, 他们试图理解和预测市场的真实运动. 在买方 (buy side), 预测真实市场的价格走势、风险评估等.\nE.g., Alibaba 的股票在涨, 你没有预测到, 却卖出了它.\n\\(\\QQ\\) quant (Risk-Neutral Probability Measure Quantitative Analyst, 风险中性测度下的量化分析) 关注的是在风险中性测度 (记作 \\(\\QQ\\)) 下的资产价格行为. 在这个虚拟的概率空间下, 所有资产的期望收益率等于无风险利率.\n在卖方 (sell side), 正确定价衍生品、避免套利."
  },
  {
    "objectID": "NSD_Lec01-FinancialEngineering_Summer2025.html#theory-of-asset-pricing",
    "href": "NSD_Lec01-FinancialEngineering_Summer2025.html#theory-of-asset-pricing",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "Theory of asset pricing",
    "text": "Theory of asset pricing\nHeuristically, pricing is a rule or a map that assigns a (unique, current) value to each (random) payoff/cashflow which can only be realized at the future investment horizon. The collection/universe of all the payoffs at the investment horizon is assumed to be equipped with a vector space structure. In other words, we would be able to add or subtract a payoff from another, and also be able to scale up or down by any (real, positive or negative) scalar. Thus, we can regard pricing as a function or a functional \\(\\Pi\\) from the space of (random) payoffs to real numbers:\n\\[\n\\Pi : \\mathcal P \\to \\R,\n\\]\nwhere \\(\\mathcal P\\) is space of payoffs at investment horizon.\nA pricing functional \\(\\Pi\\) presumably bears the following axioms\n\nLaw of one price\nMonotonicity\nLinearity\n\nBy essentially the Riesz representation theorem, a pricing function/functional, should it exist, can be characterized by the expectation of a (random) payoff weighted by a stochastic discount factor.\nThe price of any asset in the universe is given by the an expectation of discounted payoff discounted by a stochastic discount factor.\n\nNote\nIn this course we shall explore the modeling of the pricing functional."
  },
  {
    "objectID": "NSD_Lec01-FinancialEngineering_Summer2025.html#law-of-one-price",
    "href": "NSD_Lec01-FinancialEngineering_Summer2025.html#law-of-one-price",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "Law of one price",
    "text": "Law of one price\nTwo payoffs with equal values in all scenarios must have the same price."
  },
  {
    "objectID": "NSD_Lec01-FinancialEngineering_Summer2025.html#monotonicity",
    "href": "NSD_Lec01-FinancialEngineering_Summer2025.html#monotonicity",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "Monotonicity",
    "text": "Monotonicity\nIf the payoff \\(X\\) dominates the payoff \\(Y\\), i.e., \\(X &gt; Y\\) in any scenario, then the price of \\(X\\) must be higher than that of \\(Y\\)."
  },
  {
    "objectID": "NSD_Lec01-FinancialEngineering_Summer2025.html#linearity",
    "href": "NSD_Lec01-FinancialEngineering_Summer2025.html#linearity",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "Linearity",
    "text": "Linearity\nThe price of linear combination of the payoffs \\(X\\) and \\(Y\\) is the same linear combination of the price of \\(X\\) and \\(Y\\). That is,\n\\[\n\\Pi(\\alpha X + \\beta Y) = \\alpha \\Pi(X) + \\beta \\Pi(Y)\n\\]\nIf the pricing function/functional satisfies the axioms, it can be represented as a discounted expectation. Precisely, for a given payoff \\(X\\), its price is given by\n\\[\n\\Pi(X) = \\Eof{D X}\n\\]\nwhere \\(D\\) is a (positive) random variable called stochastic discount factor.\n\nNote\nThe \\(\\Eof{D}\\) is the price of zero coupon bond since, the payoff of zero coupon bond of face value 1 is \\(X \\equiv 1\\)."
  },
  {
    "objectID": "NSD_Lec01-FinancialEngineering_Summer2025.html#principle-of-no-arbitrage",
    "href": "NSD_Lec01-FinancialEngineering_Summer2025.html#principle-of-no-arbitrage",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "Principle of no arbitrage",
    "text": "Principle of no arbitrage\n\nArbitrage opportunity\nIntuitively, an arbitrage opportunity is a trade or a trading strategy that have positive payoff at the investment horizon with zero cost currently. In other words, we are able to acquire a financial position, be statically or dynamically, without being required to pay initially for entering the position.\nAny viable financial model should not permit arbitrage opportunity.\nIn reality, arbitrage opportunity does exist. However, it disappears very quickly even much quicker now due to the advent of technology, since once it is exploited, sophisticated market participants will quickly take the advantage of it, then the market reacts to it so as to reach a new status without arbitrage opportunity.\nPrinciple of no arbitrage is the core behind the theory of derivative pricing."
  },
  {
    "objectID": "NSD_Lec01-FinancialEngineering_Summer2025.html#fundamental-theorem-of-asset-pricing",
    "href": "NSD_Lec01-FinancialEngineering_Summer2025.html#fundamental-theorem-of-asset-pricing",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "Fundamental theorem of asset pricing",
    "text": "Fundamental theorem of asset pricing\nExplanations from Wikipedia.\n\nThe fundamental theorems of asset pricing (also: of arbitrage, of finance) provide necessary and sufficient conditions for a market to be arbitrage free and for a market to be complete.\n\nTo be more specific,\nIn a discrete (i.e. finite state) market, the following hold:\n\nThe First Fundamental Theorem of Asset Pricing\nA discrete market, on a discrete probability space \\((\\Omega, \\cF, \\PP)\\), is arbitrage-free if and only if there exists at least one risk neutral probability measure that is equivalent to the original probability measure, \\(\\PP\\).\n\n\nThe Second Fundamental Theorem of Asset Pricing\nAn arbitrage-free market \\((S, B)\\) consisting of a collection of stocks \\(S\\) and a risk-free bond \\(B\\) is complete if and only if there exists a unique risk-neutral measure that is equivalent to \\(\\PP\\) and has numeraire \\(B\\).\n \n\nDecentralized Finance and Automated Market Making"
  },
  {
    "objectID": "NSD_Lec01-FinancialEngineering_Summer2025.html#decentralized-finance-defi",
    "href": "NSD_Lec01-FinancialEngineering_Summer2025.html#decentralized-finance-defi",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "Decentralized Finance (DeFi)",
    "text": "Decentralized Finance (DeFi)\nQuotes from the Investopeida page:\n\n\nWhat is DeFi ?\n\nan emerging peer-to-peer financial system that uses blockchain and cryptocurrencies to allow people, businesses, or other entities to transact directly with each other.\nThe key principle behind DeFi is to remove third parties like banks from the financial system, thereby reducing costs and transaction times.\nIn the U.S., the Federal Reserve and Securities and Exchange Commission (SEC) define the rules for centralized financial institutions like banks and brokerages, which consumers rely on to access capital and financial services directly.\nDeFi challenges this centralized financial system by empowering individuals with peer-to-peer transactions.\n\nHow does DeFi work?\n\nThrough peer-to-peer financial networks, DeFi uses security protocols, connectivity, software, and hardware advancements.\nThis system eliminates intermediaries like banks and other financial service companies. These companies charge businesses and customers for using their services, which are necessary in the current system because it’s the only way to make it work.\nDeFi uses blockchain technology to reduce the need for these intermediaries."
  },
  {
    "objectID": "NSD_Lec01-FinancialEngineering_Summer2025.html#decentralized-finance-uses",
    "href": "NSD_Lec01-FinancialEngineering_Summer2025.html#decentralized-finance-uses",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "Decentralized Finance Uses",
    "text": "Decentralized Finance Uses\nQuotes from the same Investopeida page:\n\nDecentralized finance, originally conceived of as a way to bring financial services like loans and banking to those who don’t have access to them, has morphed into an industry where you can take part in many different sectors or endeavors. Here are a few of the most popular:\n\nDecentralized exchanges: The top preference for defi app users is accessing decentralized exchanges. Exchanges like Uniswap and PancakeSwap have apps that let you interact with other cryptocurrency users.\nLiquidity providers: Liquidity is the ability to sell assets quickly, a problem many cryptocurrency users have encountered. Liquidity providers are generally pools where users place funds (coins or tokens) so exchanges can provide selling (trading) opportunities for their users.\nLending/Yield Farming: There are hundreds of defi apps available that provide lending. Generally, they operate the same way as a liquidity pool, where users lock their funds in a pool and let others borrow them, receiving interest on their loans—called yield farming. Many provide flash loans, where no collateral is required from the borrower.\nGambling/Prediction Markets: Everyday, millions of dollars in cryptocurrency are used in DeFi gambling and prediction apps like Polymarket, ZKasino, Horse Racing Slot Keno Roulett, Azuro, and JuicyBet. Prediction markets are platforms that let you place bets on the outcome of nearly any event.\nNFTs: The market for non-fungible tokens has cooled somewhat, but they are still popular with niche investors and collectors."
  },
  {
    "objectID": "NSD_Lec01-FinancialEngineering_Summer2025.html#automated-market-making",
    "href": "NSD_Lec01-FinancialEngineering_Summer2025.html#automated-market-making",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "Automated Market Making",
    "text": "Automated Market Making\n\nAutomatic Market Makers (AMMs) are\n\nAlgorithms that power decentralized exchanges (DEXs).\nReplace traditional order books with liquidity pools.\nUse mathematical formulas to determine asset prices.\n\n\n\nHow AMMs Work\n\nUsers provide liquidity (crypto assets) to pools.\nTraders swap directly with the pool’s assets.\nPrices are determined by the ratio of assets within the pool.\nKey Benefits\n\nPermissionless: Anyone can trade or provide liquidity.\nAutomated: No middlemen or order books needed.\nAlways Available: 24/7 trading, regardless of market conditions."
  },
  {
    "objectID": "NSD_Lec01-FinancialEngineering_Summer2025.html#amm-vs-clob",
    "href": "NSD_Lec01-FinancialEngineering_Summer2025.html#amm-vs-clob",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "AMM vs CLOB",
    "text": "AMM vs CLOB\n\nAutomated market making are innovative solutions to the problems of decentralized exchanges. In the years prior to the implementation of AMMs, developers implemented Decentralized Exchanges (DEXs) by replicating traditional central limit order books (CLOB) used by centralized exchanges.\nThe result was excessive network transaction fees and high latency due to the difficulty in managing and maintaining a huge amount of transactions on the chain. Fortunately, the implementation of AMMs solved the problems of excessive fees and low liquidity."
  },
  {
    "objectID": "NSD_Lec01-FinancialEngineering_Summer2025.html#amm-vs-clob-1",
    "href": "NSD_Lec01-FinancialEngineering_Summer2025.html#amm-vs-clob-1",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "AMM vs CLOB",
    "text": "AMM vs CLOB\nCompared to CLOBs, AMMs offer some advantages. - Efficient computation. They have minimal storage needs, and matching computations can be done quickly, typically via constant-time closed-from algebraic computations. - In a CLOB, on the other hand, matching engine calculations may involve complex data structures and computations that scale with the number of orders. Thus AMMs are uniquely suited to the severely computation- and storage-constrained environment of the blockchain.\n\nCLOBs are not well-suited to a long-tail of illiquid assets. This is because they require the participation of active market markers. In contrast, AMMs mainly rely on passive liquidity providers (LPs).\n\n \n\nBrief Introduction to Jupyter and Python"
  },
  {
    "objectID": "NSD_Lec01-FinancialEngineering_Summer2025.html#brief-introduction-to-jupyter-notebook-and-python",
    "href": "NSD_Lec01-FinancialEngineering_Summer2025.html#brief-introduction-to-jupyter-notebook-and-python",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "Brief introduction to Jupyter notebook and Python",
    "text": "Brief introduction to Jupyter notebook and Python\nOnline resources\n\nJupyter notebook and Jupyter lab\nPython documentation\nNumpy\nScipy\nPandas\n\n\n78+12\n\n90\n\n\nFor example, this is a markdown cell.\nLet’s have some fun.\nwelcome to beijing\n\n78\n\n78\n\n\n\n# And this is a code cell"
  },
  {
    "objectID": "NSD_Lec01-FinancialEngineering_Summer2025.html#head-2",
    "href": "NSD_Lec01-FinancialEngineering_Summer2025.html#head-2",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "Head 2",
    "text": "Head 2\n\nHead 3\n\nHead 4\nLaTex we can try to type \\(\\log x \\times \\cos y\\)\nTest on integral\n\\[ \\int_{-\\infty}^\\infty e^{-\\frac{x^2}2} {\\rm d}x = \\sqrt{2\\pi}.\\]\nThis is an example for sum of an infinite series, the Riemann zeta function.\n\\[\n\\zeta(2) = \\sum_{n=1}^\\infty \\frac1{n^2} = 1 + \\frac1{2^2} + \\frac1{3^2} + \\cdots + \\frac1{n^2} + \\cdots = \\frac{\\pi^2}6\n\\]\n\nimport seaborn as sns\nimport numpy as np\n\n\n# install modules if necessary\n# pip install pandas\n# pip install seaborn\n\n\nnp.exp(1)\n\nnp.float64(2.718281828459045)\n\n\n\nimport numpy as np\n\n\nnp.exp(1), np.log(np.exp(1))\n\n(np.float64(2.718281828459045), np.float64(1.0))\n\n\n\nfrom numpy import exp\n\n\nexp(1), np.exp(1)\n\n(np.float64(2.718281828459045), np.float64(2.718281828459045))\n\n\n\n# import modules that will be commonly used in the course\nimport numpy as np \nimport matplotlib.pyplot as plt\nfrom numpy import exp, log, sqrt\nimport pandas as pd\nfrom scipy.stats import norm, t\nimport scipy.stats as ss\nimport seaborn as sns\n\n\nexp(0), np.exp(0)\n\n(np.float64(1.0), np.float64(1.0))\n\n\n\nx=6\nx\n\n6\n\n\n\n# list\ntickers = ['aapl', 'goog', 'spx']\n\n# tuple\nprices = (140, 600, 4500)\n\n# dict/dictionary\nstocks = {'ticker': tickers, 'price': prices}\nstocks\n\n{'ticker': ['aapl', 'goog', 'spx'], 'price': (140, 600, 4500)}\n\n\n\nstocks['ticker'], stocks['price']\n\n(['aapl', 'goog', 'spx'], (140, 600, 4500))\n\n\n\n# present data as a pandas.DataFrame\ndf = pd.DataFrame({'ticker': tickers, 'price': prices})\ndf\n\n\n\n\n\n\n\n\nticker\nprice\n\n\n\n\n0\naapl\n140\n\n\n1\ngoog\n600\n\n\n2\nspx\n4500\n\n\n\n\n\n\n\n\n# add a column to pandas.DataFrame\ndf['index'] = (6, 8, 9)\ndf\n\n\n\n\n\n\n\n\nticker\nprice\nindex\n\n\n\n\n0\naapl\n140\n6\n\n\n1\ngoog\n600\n8\n\n\n2\nspx\n4500\n9\n\n\n\n\n\n\n\n\n# concatenate lists\ntaiho = [3, 2, 'this is a string']\nprint(taiho)\ntaiho += [90]\nprint(taiho)\nprint(['bye'] + taiho + ['hello'])\n\n[3, 2, 'this is a string']\n[3, 2, 'this is a string', 90]\n['bye', 3, 2, 'this is a string', 90, 'hello']\n\n\n\nnp.identity(3)\n\narray([[1., 0., 0.],\n       [0., 1., 0.],\n       [0., 0., 1.]])\n\n\n\n# matrix mulplications\nA = np.identity(4)\n#A\nprint(A)\nprint(2*A) \n2*A + 1\n\n[[1. 0. 0. 0.]\n [0. 1. 0. 0.]\n [0. 0. 1. 0.]\n [0. 0. 0. 1.]]\n[[2. 0. 0. 0.]\n [0. 2. 0. 0.]\n [0. 0. 2. 0.]\n [0. 0. 0. 2.]]\n\n\narray([[3., 1., 1., 1.],\n       [1., 3., 1., 1.],\n       [1., 1., 3., 1.],\n       [1., 1., 1., 3.]])\n\n\n\nB = [1, 2, 3]\nc = [4, 5, 6]\nprint(B + c)\nnp.array(B) + np.array(c)\n\n[1, 2, 3, 4, 5, 6]\n\n\narray([5, 7, 9])\n\n\n\nf = lambda x: 2*x**2 + 1\n[f(i) for i in range(9)]\n\n[1, 3, 9, 19, 33, 51, 73, 99, 129]\n\n\n\nf(np.arange(9))\n\narray([  1,   3,   9,  19,  33,  51,  73,  99, 129])\n\n\n\nnp.linspace(0, 1, 10)\n\narray([0.        , 0.11111111, 0.22222222, 0.33333333, 0.44444444,\n       0.55555556, 0.66666667, 0.77777778, 0.88888889, 1.        ])\n\n\n\nnp.arange(0, 1, 0.1)\n\narray([0. , 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9])\n\n\n\nB = np.arange(16)\nprint(B)\nB = np.arange(16).reshape(4, 4)\nB\n\n[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15]\n\n\narray([[ 0,  1,  2,  3],\n       [ 4,  5,  6,  7],\n       [ 8,  9, 10, 11],\n       [12, 13, 14, 15]])\n\n\n\nA, B\n\n(array([[1., 0., 0., 0.],\n        [0., 1., 0., 0.],\n        [0., 0., 1., 0.],\n        [0., 0., 0., 1.]]),\n array([[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11],\n        [12, 13, 14, 15]]))\n\n\n\nd = np.array([3, 1, 4])\n\n\nA, d\n\n(array([[1., 0., 0., 0.],\n        [0., 1., 0., 0.],\n        [0., 0., 1., 0.],\n        [0., 0., 0., 1.]]),\n array([3, 1, 4]))\n\n\n\nA*d\n\n\n---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\nCell In[30], line 1\n----&gt; 1 A*d\n\nValueError: operands could not be broadcast together with shapes (4,4) (3,) \n\n\n\n\nB\n\narray([[ 0,  1,  2,  3],\n       [ 4,  5,  6,  7],\n       [ 8,  9, 10, 11],\n       [12, 13, 14, 15]])\n\n\n\n# entrywise multiplication, if they have the same shape\nprint(A*B)\n\n# matrix multiplication, if they are conformable\nA.dot(B), B.dot(A)\n\n[[ 0.  0.  0.  0.]\n [ 0.  5.  0.  0.]\n [ 0.  0. 10.  0.]\n [ 0.  0.  0. 15.]]\n\n\n(array([[ 0.,  1.,  2.,  3.],\n        [ 4.,  5.,  6.,  7.],\n        [ 8.,  9., 10., 11.],\n        [12., 13., 14., 15.]]),\n array([[ 0.,  1.,  2.,  3.],\n        [ 4.,  5.,  6.,  7.],\n        [ 8.,  9., 10., 11.],\n        [12., 13., 14., 15.]]))\n\n\n\nvv, ww = np.array([1,2,4]), np.array([3, 4])\n2*vv + 1, ww\n\n(array([3, 5, 9]), array([3, 4]))\n\n\n\nc = np.arange(1, 5)\nc\n\narray([1, 2, 3, 4])\n\n\n\nc, B\n\n(array([1, 2, 3, 4]),\n array([[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11],\n        [12, 13, 14, 15]]))\n\n\n\nc = np.arange(1, 5)\nc\n\narray([1, 2, 3, 4])\n\n\n\nc, B\n\n(array([1, 2, 3, 4]),\n array([[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11],\n        [12, 13, 14, 15]]))\n\n\n\nc*B\n\narray([[ 0,  2,  6, 12],\n       [ 4, 10, 18, 28],\n       [ 8, 18, 30, 44],\n       [12, 26, 42, 60]])\n\n\n\nc.dot(B)\n\narray([ 80,  90, 100, 110])\n\n\n\nB.dot(c)\n\narray([ 20,  60, 100, 140])\n\n\n\nc[3], B[1,1]\n\n(4, 5)"
  },
  {
    "objectID": "NSD_Lec01-FinancialEngineering_Summer2025.html#numpy.arange-vs-numpy.linspace",
    "href": "NSD_Lec01-FinancialEngineering_Summer2025.html#numpy.arange-vs-numpy.linspace",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "numpy.arange vs numpy.linspace",
    "text": "numpy.arange vs numpy.linspace\n\nprint(np.arange(0, 1, 0.1))\nnp.linspace(0, 1, 10)\n\n[0.  0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9]\n\n\narray([0.        , 0.11111111, 0.22222222, 0.33333333, 0.44444444,\n       0.55555556, 0.66666667, 0.77777778, 0.88888889, 1.        ])"
  },
  {
    "objectID": "NSD_Lec01-FinancialEngineering_Summer2025.html#probability-distributions-in-scipy.stats",
    "href": "NSD_Lec01-FinancialEngineering_Summer2025.html#probability-distributions-in-scipy.stats",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "Probability distributions in scipy.stats",
    "text": "Probability distributions in scipy.stats\n\nDistributions\n\nnorm for normal distribution\nexpon for exponential distribution\nf for \\(F\\)-distribution\nt for \\(t\\)-distribution\nchi2 for \\(\\chi^2\\)\n\nMethods\n\ncdf for cumulative distribution function\npdf for probability density function\nrvs for random samples\nppf for percentile/quantile function\nsf for survival function\n\n\n\nc\n\narray([1, 2, 3, 4])\n\n\n\nss.expon.ppf(0)\n\nnp.float64(0.0)\n\n\n\nss.expon.ppf(0.75)\n\nnp.float64(1.3862943611198906)\n\n\n\n# set random seed for reproducing the same result\n#np.random.seed(1414)\nss.norm.rvs(size=100)\n\narray([ 1.90500963e+00, -9.26189353e-01,  2.59899601e-02, -3.88504372e-02,\n       -4.99088973e-01, -3.28268840e-01, -9.02064852e-01, -1.12596435e+00,\n       -5.82834299e-01,  6.87782748e-01, -1.58545821e+00, -1.02809283e+00,\n        2.23827542e-01,  1.11105370e+00, -7.62913181e-01, -9.50884319e-02,\n        3.41188487e-01,  6.23140174e-01, -8.26578120e-01,  2.24530170e+00,\n        1.95859043e+00, -7.95248922e-01, -4.33296750e-01, -8.46815528e-01,\n        1.21972014e-01,  2.56056794e+00,  1.28634181e+00,  1.58244716e+00,\n        1.53643255e+00, -9.02912788e-01, -6.81755257e-01,  1.25675463e+00,\n       -3.22728800e-01, -2.23427113e-01,  9.37736522e-01,  1.84954428e-01,\n       -1.47368965e+00,  5.13991467e-01, -7.38149140e-01,  1.28392808e-01,\n       -2.58651738e-01, -9.77344921e-01, -1.90288421e+00,  1.98369021e-01,\n        8.24466724e-01, -1.03827555e+00,  1.80616310e+00, -1.37742816e+00,\n       -4.07164649e-01, -1.95352299e+00, -1.05000140e+00,  1.02700912e+00,\n        5.40498556e-01, -2.82708805e-01, -2.87597562e-01, -8.41689373e-01,\n        5.93505669e-02,  4.53903314e-01, -1.15212311e+00, -5.69057683e-01,\n       -2.37658188e-01,  1.10694851e+00, -5.46694151e-01, -2.82575234e-01,\n        1.09209917e-01, -1.66039357e-01, -2.41407120e-01,  5.78674565e-01,\n       -4.78640827e-01, -1.44091328e+00, -1.26918381e+00,  1.31760542e+00,\n       -9.97741445e-01, -8.34399700e-01, -7.37834400e-01,  2.59507750e+00,\n       -3.45976692e-01, -8.36221569e-01,  3.00247725e-02, -9.12115482e-01,\n       -5.11351475e-01, -2.22029626e-01,  3.77572064e-01, -8.23316424e-04,\n        4.47546024e-01,  5.37300771e-01,  5.65936543e-03,  6.33369379e-01,\n       -6.42294255e-01, -6.51539813e-01,  1.66518313e+00, -1.13719462e+00,\n       -1.28257270e-01,  2.05714889e+00, -3.50942579e-01, -2.11867973e-01,\n        1.81174643e+00, -1.17653604e+00, -1.23539063e+00,  9.21296346e-01])\n\n\n\n# restructure in to a matrix\nnp.random.seed(0)\nx = norm.rvs(size=10)\nx.reshape(5, 2)\n\narray([[ 1.76405235,  0.40015721],\n       [ 0.97873798,  2.2408932 ],\n       [ 1.86755799, -0.97727788],\n       [ 0.95008842, -0.15135721],\n       [-0.10321885,  0.4105985 ]])\n\n\n\nx = ss.chi2.rvs(size=1000, df=3)\nx.std()\n#x.mean(), x.std()\n\nnp.float64(2.272882482740998)\n\n\n\nx = norm.rvs(size=10000)\nx.mean(), x.std()\n\n(np.float64(-0.00694190524278084), np.float64(1.0016440451939277))\n\n\n\n# t distribution\nx = ss.t.rvs(size=20, df=3)\nx = x.reshape(5, 4)\nx.std(axis=0), x.mean(axis=1)\n\n(array([1.37879318, 0.90832706, 0.54941869, 1.06259522]),\n array([-0.25745669, -1.00116667,  0.49639331, -0.14980356,  0.09080126]))\n\n\n\n# set seed for reproducing the same result\nnp.random.seed(3141)\nA = ss.t.rvs(size=50, df=3).reshape(10, 5)\nprint(A)\n\n# columns means, row means, mean\nA.mean(axis=0), A.mean(axis=1), A.mean(), A[0,:].mean(), A[:,1].mean()\n\n[[ 0.38460161  0.30557167  0.98733417 -0.91383565  0.29287735]\n [-4.80767259  1.75715301  0.56930703 -0.18584678 -0.27178843]\n [-2.22506467  0.75044717  0.64565414 -6.61192184  0.52245651]\n [-3.9920851  -0.09520588 -1.13886262  0.10359085  0.98480259]\n [ 1.14992001 -0.0721649   1.11039801 -1.2657385   0.24885729]\n [ 0.83122811  1.1900472   2.20384757  0.241097    0.7355704 ]\n [ 0.35649725 -0.05568609  0.91596184  0.57625402 -1.13201945]\n [-0.33241969 -0.86425951  0.70613486  0.58578441  0.83649889]\n [-3.05161328 -0.12689271 -0.95750987  0.43748489 -0.01460354]\n [ 0.91656328  0.61010723 -1.11239471 -0.96544386 -0.38342567]]\n\n\n(array([-1.07700451,  0.33991172,  0.39298704, -0.79985755,  0.18192259]),\n array([ 0.21130983, -0.58776955, -1.38368574, -0.82755203,  0.23425438,\n         1.04035806,  0.13220151,  0.18634779, -0.7426269 , -0.18691875]),\n -0.19240813934357784,\n 0.21130982710311189,\n 0.3399117196808371)\n\n\n\nA.std(axis=0), A.std(axis=1), A.std()\n\n(array([2.1202166 , 0.71816393, 1.05120007, 2.04105521, 0.61667702]),\n array([0.61866546, 2.23188063, 2.8407215 , 1.72041687, 0.88883698,\n        0.65598228, 0.70644573, 0.66713118, 1.23930652, 0.81904152]),\n 1.5861889765952781)\n\n\n\nf(3.14)\n\n0.0015926529164868282\n\n\n\n# plot graph of a function\nf = lambda x: np.sin(x)\ng = lambda x: np.sin(x - np.pi/6)\nh = lambda x: np.sin(x - np.pi/4)\nx = np.linspace(0, 2*np.pi, 200)\n\n# plot\nplt.figure(figsize=(9, 6))\nplt.plot(x, f(x), 'r', lw=1, label='$y = f(x)$')\nplt.plot(x, g(x), 'k--', lw=1, label='$y = g(x)$')\nplt.plot(x, h(x), 'b-.', lw=1, label='$y = h(x)$')\nplt.xlabel('$x$', fontsize=12)\nplt.ylabel('$y$', fontsize=25)\n#plt.ylabel('$y$', fontsize=12)\n#plt.title('Whatever the Title', fontsize=15)\nplt.grid()\n#plt.legend();\n\n\n\n\n\n\n\n\n\n# examples for histogram\n# set seed\nnp.random.seed(2718)\nsample = pd.DataFrame(norm.rvs(size=int(5e4)))\nsample.head(10), sample.tail(10)\n\n(          0\n 0  1.722518\n 1 -0.626257\n 2 -3.533687\n 3  0.716898\n 4  1.353317\n 5  1.603105\n 6  0.501179\n 7  0.748855\n 8 -1.790165\n 9  0.533090,\n               0\n 49990  0.004426\n 49991  0.235329\n 49992 -0.188821\n 49993 -0.183680\n 49994  0.475978\n 49995 -1.139552\n 49996 -0.162364\n 49997 -0.355614\n 49998 -0.793454\n 49999  1.334050)\n\n\n\nsample.describe().transpose()\n#sample.describe().transpose()\n\n\n\n\n\n\n\n\ncount\nmean\nstd\nmin\n25%\n50%\n75%\nmax\n\n\n\n\n0\n50000.0\n0.000345\n1.002402\n-4.568631\n-0.675698\n0.006211\n0.681126\n4.001952\n\n\n\n\n\n\n\n\n# generate random samples from standard normal\nsample = pd.DataFrame(norm.rvs(size=int(5e4))) # 1e5 = 10^5, 1e3 = 10^3 = 1000\n\nx = np.linspace(sample.min(), sample.max(), 200)\ny = norm.pdf(x)\n\n# histogram by hvplot.hist\n#sample.hvplot.hist(bins=50, height=350, width=550, label='histogram') * \\\n#hv.Curve((x, y*8500)).opts(color='red', line_dash='dashed')\n\n\n# histogram by seaborn.histplot\n# we shall mostly using this module for plotting histograms\nplt.figure(figsize=(9, 6))\nsns.histplot(sample[0], bins=50, stat='density', kde=True, label='histogram')\n\n#sns.histplot(sample[0], bins=50, color='k', fill=False)\nplt.xlabel('$X$', fontsize=12)\nplt.title('Histogram', fontsize=18)\n\n# superimpose density of standard normal \nx = np.linspace(sample.min(), sample.max(), 200)\ny = norm.pdf(x)\nplt.plot(x, y, 'r--', label='normal density')\nplt.legend();\n\n\n\n\n\n\n\n\n\nsample.columns = ['X']\n\n\n# histogram using built-in pandas.DataFrame method\nsample.plot(kind='hist', bins=50, density=True, histtype='step')\n# superimpose the density\nx = np.linspace(sample.min(), sample.max(), 200)\ny = norm.pdf(x)\nplt.plot(x, y, 'r-.', label='normal density')\nplt.xlabel('$X$', fontsize=12)\nplt.title('Histogram', fontsize=18)\nplt.legend();\n\n\n\n\n\n\n\n\n\n# histogram using pyplot\nplt.figure(figsize=(9, 6))\nplt.hist(sample, density=True, bins=50, histtype='bar', rwidth=0.85, label='histogram')\n\n# superimpose the density\nx = np.linspace(sample.min(), sample.max(), 200)\ny = norm.pdf(x)\nplt.plot(x, y, 'r-.', label='normal density')\nplt.xlabel('$X$', fontsize=12)\nplt.legend();"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "qf-slides",
    "section": "",
    "text": "Here are the Topics in Quantitative Finance slides.\n\nLec 01 Financial Engineering\nLec 02 Stochastic Calculus\nLec 03 Black-Scholes Model I"
  },
  {
    "objectID": "NSD_Lec02-StochCal_Summer2025.html",
    "href": "NSD_Lec02-StochCal_Summer2025.html",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "",
    "text": "Tai-Ho Wang (王 太和)\n\n\n\n\n\\[\n\\renewcommand{\\d}{\\text{d} }\n\\newcommand{\\bea}{\\begin{align}}\n\\newcommand{\\eea}{\\end{align}}\n\\newcommand{\\supp}{\\mathrm{supp}}\n\\newcommand{\\F}{\\mathcal{F} }\n\\newcommand{\\cF}{\\mathcal{F} }\n\\newcommand{\\E}{\\mathbb{E} }\n\\newcommand{\\Eof}[1]{\\mathbb{E}\\left[ #1 \\right]}\n\\def\\Cov{{ \\text{Cov} }}\n\\def\\Var{{ \\text{Var} }}\n\\newcommand{\\1}{\\mathbb{1} }\n\\newcommand{\\p}{\\partial}\n\\renewcommand{\\P}{\\mathbb{P} }\n\\newcommand{\\PP}{\\mathbb{P} }\n\\newcommand{\\Pof}[1]{\\mathbb{P}\\left[ #1 \\right]}\n\\newcommand{\\QQ}{\\mathbb{Q} }\n\\renewcommand{\\R}{\\mathbb{R} }\n\\newcommand{\\DD}{\\mathbb{D} }\n\\newcommand{\\HH}{\\mathbb{H} }\n\\newcommand{\\spn}{\\mathrm{span} }\n\\newcommand{\\cov}{\\mathrm{cov} }\n\\newcommand{\\HS}{\\mathcal{L}_{\\mathrm{HS}} }\n\\newcommand{\\Hess}{\\mathrm{Hess} }\n\\newcommand{\\trace}{\\mathrm{trace} }\n\\newcommand{\\LL}{\\mathcal{L} }\n\\newcommand{\\s}{\\mathcal{S} }\n\\newcommand{\\ee}{\\mathcal{E} }\n\\newcommand{\\ff}{\\mathcal{F} }\n\\newcommand{\\hh}{\\mathcal{H} }\n\\newcommand{\\bb}{\\mathcal{B} }\n\\newcommand{\\dd}{\\mathcal{D} }\n\\newcommand{\\g}{\\mathcal{G} }\n\\newcommand{\\half}{\\frac{1}{2} }\n\\newcommand{\\T}{\\mathcal{T} }\n\\newcommand{\\bit}{\\begin{itemize}}\n\\newcommand{\\eit}{\\end{itemize}}\n\\newcommand{\\beq}{\\begin{equation}}\n\\newcommand{\\eeq}{\\end{equation}}\n\\newcommand{\\tr}{\\text{tr}}\n\\]"
  },
  {
    "objectID": "NSD_Lec02-StochCal_Summer2025.html#lecture-2-crash-course-on-stochastic-calculus",
    "href": "NSD_Lec02-StochCal_Summer2025.html#lecture-2-crash-course-on-stochastic-calculus",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "",
    "text": "Tai-Ho Wang (王 太和)\n\n\n\n\n\\[\n\\renewcommand{\\d}{\\text{d} }\n\\newcommand{\\bea}{\\begin{align}}\n\\newcommand{\\eea}{\\end{align}}\n\\newcommand{\\supp}{\\mathrm{supp}}\n\\newcommand{\\F}{\\mathcal{F} }\n\\newcommand{\\cF}{\\mathcal{F} }\n\\newcommand{\\E}{\\mathbb{E} }\n\\newcommand{\\Eof}[1]{\\mathbb{E}\\left[ #1 \\right]}\n\\def\\Cov{{ \\text{Cov} }}\n\\def\\Var{{ \\text{Var} }}\n\\newcommand{\\1}{\\mathbb{1} }\n\\newcommand{\\p}{\\partial}\n\\renewcommand{\\P}{\\mathbb{P} }\n\\newcommand{\\PP}{\\mathbb{P} }\n\\newcommand{\\Pof}[1]{\\mathbb{P}\\left[ #1 \\right]}\n\\newcommand{\\QQ}{\\mathbb{Q} }\n\\renewcommand{\\R}{\\mathbb{R} }\n\\newcommand{\\DD}{\\mathbb{D} }\n\\newcommand{\\HH}{\\mathbb{H} }\n\\newcommand{\\spn}{\\mathrm{span} }\n\\newcommand{\\cov}{\\mathrm{cov} }\n\\newcommand{\\HS}{\\mathcal{L}_{\\mathrm{HS}} }\n\\newcommand{\\Hess}{\\mathrm{Hess} }\n\\newcommand{\\trace}{\\mathrm{trace} }\n\\newcommand{\\LL}{\\mathcal{L} }\n\\newcommand{\\s}{\\mathcal{S} }\n\\newcommand{\\ee}{\\mathcal{E} }\n\\newcommand{\\ff}{\\mathcal{F} }\n\\newcommand{\\hh}{\\mathcal{H} }\n\\newcommand{\\bb}{\\mathcal{B} }\n\\newcommand{\\dd}{\\mathcal{D} }\n\\newcommand{\\g}{\\mathcal{G} }\n\\newcommand{\\half}{\\frac{1}{2} }\n\\newcommand{\\T}{\\mathcal{T} }\n\\newcommand{\\bit}{\\begin{itemize}}\n\\newcommand{\\eit}{\\end{itemize}}\n\\newcommand{\\beq}{\\begin{equation}}\n\\newcommand{\\eeq}{\\end{equation}}\n\\newcommand{\\tr}{\\text{tr}}\n\\]"
  },
  {
    "objectID": "NSD_Lec02-StochCal_Summer2025.html#outline-of-lecture-2",
    "href": "NSD_Lec02-StochCal_Summer2025.html#outline-of-lecture-2",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "Outline of Lecture 2",
    "text": "Outline of Lecture 2\n\nBrownian motion\nStochastic integral\nIto’s formula\nFeynman-Kac formula\n\nCharacteristic function for Lévy area"
  },
  {
    "objectID": "NSD_Lec02-StochCal_Summer2025.html#definition-of-brownian-motion",
    "href": "NSD_Lec02-StochCal_Summer2025.html#definition-of-brownian-motion",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "Definition of Brownian motion",
    "text": "Definition of Brownian motion\nLet \\((\\Omega,\\cF_t,\\P)\\) be a filtered probability space.\nA stochastic process \\(B_t\\) adapted to \\(\\cF_t\\) is called a (standard) Brownian motion or a Wiener process if it satisfies the following conditions\n\n\\(\\P[\\omega: B_0(\\omega) = 0] = 1\\), i.e., the process starts at zero almost surely.\nFor any \\(0 \\leq s &lt; t\\), the random variable \\(B_t - B_s\\) is normally distributed with mean 0 and variance \\(t-s\\), i.e., for any \\(a&lt;b\\), \\[\n\\P[a \\leq B_t - B_s \\leq b] = \\frac{1}{\\sqrt{2\\pi(t-s)}}\\int_a^b e^{-\\frac{x^2}{2(t-s)}} {\\rm d} x.\n\\]\n\\(B_t\\) has independent increment, i.e., for any \\(0\\leq t_1 &lt; t_2 &lt; \\cdots &lt; t_n\\), the random variables \\[\n  B_{t_1}, \\; B_{t_2} - B_{t_1},\\; \\cdots, \\; B_{t_n} - B_{t_{n-1}}\n\\] are independent.\nAlmost all sample paths of \\(B_t\\) are continuous functions, i.e., \\[\n  \\P[\\omega:B_t(\\omega) \\text{ is continuous } ] = 1\n\\]\n\n\nRemark\n\nA Brownian motion is sometimes defined as a stochastic process satisfying only the first 3 conditions in the definition. Such a process always has continuous modification by applying Kolmogorov’s continuity criterion.\nThe standard Brownian motion starts at 0. A Brownian motion starts at \\(x\\neq 0\\) is obtain by shifting \\(x + B_t\\).\n\\(X_t = x + \\sigma B_t\\), \\(X_t\\) has mean \\(x\\) and variance \\(\\sigma^2 t\\), whereas \\(X_t - X_s\\) has mean \\(0\\) variance \\(\\sigma^2(t-s)\\)."
  },
  {
    "objectID": "NSD_Lec02-StochCal_Summer2025.html#kolmogorovs-continuity-criterion",
    "href": "NSD_Lec02-StochCal_Summer2025.html#kolmogorovs-continuity-criterion",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "Kolmogorov’s continuity criterion",
    "text": "Kolmogorov’s continuity criterion\n\nTheorem\nA process \\(X\\), for which there exist three constants \\(\\alpha\\), \\(\\beta\\), \\(C &gt; 0\\) such that \\[\n  \\Eof{|X_{t+h} - X_t|^{\\alpha}} \\leq C h^{1 + \\beta}\n\\] for every \\(t\\) and \\(h\\), has a modification which is almost surely continuous.\n注: Modification(修正), 设概率空间 \\((\\Omega, \\cF, \\P)\\) 上有两个指标集为 \\(T\\) 的随机过程 \\(X=\\{X_t\\}\\) 和 \\(Y=\\{Y_t\\}\\), 那么我们称 \\(Y\\) 是 \\(X\\) 的修正, 如果对于 \\(\\forall t \\in T\\) 有: \\[\n\\P[X_t = Y_t] = 1.\n\\] 之所以把上面的概念称作修正, 是因为 \\(Y\\) 相当于是把原过程 \\(X\\) 调整了极少量的点之后得来的.\nFor Brownian motion \\(B_t\\), since the random variable \\(B_{t+h} - B_t\\) is centered Gaussian with variance \\(h\\), we have\n\\[\n   \\Eof{(B_{t+h} - B_t)^4} = 3 h^2.\n\\]\nTherefore, by taking \\(\\alpha=4\\), \\(\\beta = 1\\), and \\(C=3\\), the Kolmogorov’s continuity criterion applies."
  },
  {
    "objectID": "NSD_Lec02-StochCal_Summer2025.html#historical-note",
    "href": "NSD_Lec02-StochCal_Summer2025.html#historical-note",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "Historical note",
    "text": "Historical note\nQuotes from the Wikipage:\n\n“Brownian motion or pedesis (from Greek: πήδησις /pɛ̌ːdɛːsis/”leaping”) is the random motion of particles suspended in a fluid (a liquid or a gas) resulting from their collision with the quick atoms or molecules in the gas or liquid.”\n“This transport phenomenon is named after the botanist Robert Brown. In 1827, while looking through a microscope at particles found in pollen grains in water, he noted that the particles moved through the water but was not able to determine the mechanisms that caused this motion.”\n“The first person to describe the mathematics behind Brownian motion was Thorvald N. Thiele in a paper on the method of least squares published in 1880. This was followed independently by Louis Bachelier in 1900 in his PhD thesis”The theory of speculation”, in which he presented a stochastic analysis of the stock and option markets. Albert Einstein (in one of his 1905 papers) and Marian Smoluchowski (1906) brought the solution of the problem to the attention of physicists, and presented it as a way to indirectly confirm the existence of atoms and molecules. Their equations describing Brownian motion were subsequently verified by the experimental work of Jean Baptiste Perrin in 1908.”"
  },
  {
    "objectID": "NSD_Lec02-StochCal_Summer2025.html#андрей-николаевич-колмогоров",
    "href": "NSD_Lec02-StochCal_Summer2025.html#андрей-николаевич-колмогоров",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "Андре́й Никола́евич Колмого́ров",
    "text": "Андре́й Никола́евич Колмого́ров\n\n\n\nCourtesy: Photo from Encyclopedia Britannica\nQuotes from the Wikipage:\n\nAndrey Nikolaevich Kolmogorov (Russian: Андре́й Никола́евич Колмого́ров), 25 April 1903 – 20 October 1987) was a Soviet mathematician who contributed to the mathematics of probability theory, topology, intuitionistic logic, turbulence, classical mechanics, algorithmic information theory and computational complexity."
  },
  {
    "objectID": "NSD_Lec02-StochCal_Summer2025.html#nobert-wiener",
    "href": "NSD_Lec02-StochCal_Summer2025.html#nobert-wiener",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "Nobert Wiener",
    "text": "Nobert Wiener\n\n\n\nCourtesy: Photo from Encyclopedia Britannica\nQuotes from the Wikipage:\n\nNorbert Wiener, November 26, 1894 – March 18, 1964, was an American mathematician and philosopher. He was a professor of mathematics at the Massachusetts Institute of Technology. A child prodigy, Wiener later became an early researcher in stochastic and mathematical noise processes, contributing work relevant to electronic engineering, electronic communication, and control systems."
  },
  {
    "objectID": "NSD_Lec02-StochCal_Summer2025.html#properties-of-brownian-motion",
    "href": "NSD_Lec02-StochCal_Summer2025.html#properties-of-brownian-motion",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "Properties of Brownian motion",
    "text": "Properties of Brownian motion\nThe following properties hold for Brownian motion \\(B_t\\).\n\nTime-homogeneity For any \\(s&gt;0\\), the process \\(B_{t+s} - B_s\\), \\(t\\geq 0\\) is also a Brownian motion and is independent of the \\(\\sigma\\)-algebra \\(\\sigma(B_u, u\\leq s)\\).\nSymmetry The process \\(-B_t\\), \\(t\\geq 0\\), is a Brownian motion.\nSelf-similarity For every \\(c &gt; 0\\), the process \\(cB_{t/c^2}\\), \\(t \\geq 0\\), is a Brownian motion.\nTime inversion The process \\(X\\) defined by \\(X_0=0\\), \\(X_t = tB_{1/t}\\) for \\(t&gt;0\\), is a Brownian motion."
  },
  {
    "objectID": "NSD_Lec02-StochCal_Summer2025.html#distributional-properties-of-brownian-motion",
    "href": "NSD_Lec02-StochCal_Summer2025.html#distributional-properties-of-brownian-motion",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "Distributional properties of Brownian motion",
    "text": "Distributional properties of Brownian motion\nBrownian motion is a Gaussian process, it is fully characterized by the mean and the covariance functions.\n\n\\(\\Eof{B_t} = 0\\) for all \\(t\\)\n\\(\\cov(B_t,B_s) = \\min\\{s,t\\}\\)\n\nTo calculate the covariance, without loss of generality, we assume \\(s &lt; t\\).\n\\[\\begin{align*}\n  \\cov(B_t,B_s) &= \\Eof{B_t\\, B_s} = \\Eof{(B_t - B_s + B_s)B_s} = \\Eof{(B_t - B_s)B_s} + s \\\\\n  &= \\Eof{B_t - B_s}\\,\\Eof{B_s} + s \\quad (\\because \\text{ independent increment}) \\\\\n  &= s = \\min\\{s,t\\}.\n\\end{align*}\\]"
  },
  {
    "objectID": "NSD_Lec02-StochCal_Summer2025.html#review-gaussian-process",
    "href": "NSD_Lec02-StochCal_Summer2025.html#review-gaussian-process",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "Review: Gaussian process",
    "text": "Review: Gaussian process\nA stochastic process \\(X_t\\) is called a Gaussian process if all its finite dimensional distributions are multivariate normally distributed. Thus, a Gaussian process is fully characterized by its mean function \\(\\mu(t) = \\Eof{X_t}\\) and (auto)covariance function \\(\\gamma(t,s) = \\cov(X_t,X_s)\\).\n\nCommonly encountered Gaussian processes\n\nBrownian motion\nBrownian motion with deterministic drift\nBrownian bridge\nOrnstein-Uhlenbeck process\nfractional Brownian motion"
  },
  {
    "objectID": "NSD_Lec02-StochCal_Summer2025.html#carl-friedrich-gauss",
    "href": "NSD_Lec02-StochCal_Summer2025.html#carl-friedrich-gauss",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "Carl Friedrich Gauss",
    "text": "Carl Friedrich Gauss\n\n\n\nCourtesy: Wikipedia\nQuote from the Wikipage:\n\nJohann Carl Friedrich Gauss (/ɡaʊs/; German: Gauß [kaʁl ˈfʁiːdʁɪç ˈɡaʊs]; Latin: Carolus Fridericus Gauss; 30 April 1777 – 23 February 1855) was a German mathematician and physicist who made significant contributions to many fields in mathematics and science. Sometimes referred to as the Princeps mathematicorum (Latin for ‘“the foremost of mathematicians”’) and “the greatest mathematician since antiquity”, Gauss had an exceptional influence in many fields of mathematics and science, and is ranked among history’s most influential mathematicians."
  },
  {
    "objectID": "NSD_Lec02-StochCal_Summer2025.html#variation-of-a-function",
    "href": "NSD_Lec02-StochCal_Summer2025.html#variation-of-a-function",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "Variation of a function",
    "text": "Variation of a function\nLet \\(f:[0,T] \\to \\R\\). Let \\(\\Pi_n = \\{0=t_0 &lt; t_1 &lt; \\cdots &lt; t_n = T \\}\\) be a sequence of partitions of the finite interval \\([0,T]\\) and denote \\(\\displaystyle\\|\\Pi_n\\| = \\max_n\\{ t_i - t_{i-1} \\}\\). The variation \\(V_f(T)\\) of \\(f\\) in \\([0,T]\\) is defined as \\[\n  V_f(T) = \\lim_{\\|\\Pi_n\\|\\to 0} \\sum_{i=1}^n |f(t_i) - f(t_{i-1})|\n\\] provided the limit exists.\n\nRemark\nAn important property for functions of finite variation is that it can be uniquely written as the sum of an increasing function and a decreasing function.\n实际上记录了在 \\(y\\) 轴上经历的路程.\n\n递增函数: Variation = 终值 - 初值."
  },
  {
    "objectID": "NSD_Lec02-StochCal_Summer2025.html#quadratic-variation-and-covariation",
    "href": "NSD_Lec02-StochCal_Summer2025.html#quadratic-variation-and-covariation",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "Quadratic variation and covariation",
    "text": "Quadratic variation and covariation\nLet \\(f,g:[0,T] \\to \\R\\). Let \\(\\Pi_n = \\{0=t_0 &lt; t_1 &lt; \\cdots &lt; t_n = T\\}\\) be a sequence of partitions of the finite interval \\([0,T]\\) and denote \\(\\|\\Pi_n\\| = \\max_n\\{ t_i - t_{i-1} \\}\\).\n\nQuadratic variation\nThe quadratic variation of \\(f\\), denoted by \\([f](T)\\), in \\([0,T]\\) is defined as\n\\[\n  [f](T) = \\lim_{\\|\\Pi_n\\|\\to 0} \\sum_{i=1}^n |f(t_i) - f(t_{i-1})|^2\n\\]\nprovided the limit exists.\n\n\nQuadratic covariation\nThe quadratic covariation of \\(f\\) and \\(g\\), denoted by \\([f,g](T)\\), in \\([0,T]\\) is defined as\n\\[\n  [f,g](T) = \\lim_{\\|\\Pi_n\\|\\to 0} \\sum_{i=1}^n [f(t_i) - f(t_{i-1})][g(t_i) - g(t_{i-1})]\n\\]\nprovided the limit exists.\n\n\nRemark\nOne can define even higher order variations, say, cubic variation. However, if the variation at some order is finite, all the higher order variations vanish. For example, the cubic variation of Brownian motion vanishes since it has finite quadratic variation."
  },
  {
    "objectID": "NSD_Lec02-StochCal_Summer2025.html#quadratic-variation-of-brownian-motion",
    "href": "NSD_Lec02-StochCal_Summer2025.html#quadratic-variation-of-brownian-motion",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "Quadratic variation of Brownian motion",
    "text": "Quadratic variation of Brownian motion\nLet \\(\\Delta_n = \\{a=t_0 &lt; t_1 &lt; \\cdots &lt; t_n = b \\}\\) be a partition of a finite interval \\([a,b]\\). Then\n\\[\n  \\lim_{n\\to\\infty}\\sum_{i=1}^n (B_{t_{i}} - B_{t_{i-1}})^2 = b-a \\quad \\text{ in } L^2(\\Omega)\n\\]\nas \\(\\|\\Delta_n\\| = \\displaystyle\\max_{1\\leq i \\leq n}(t_i - t_{i-1})\\) goes to \\(0\\).\n注: \\(L^p\\) 空间实际上是 \\(p\\) 次可积函数组成的空间. \\(L^p\\) Space\nIn other words, the quadratic variation \\([B]_t\\) of Brownian motion \\(B_t\\) in \\([0,t]\\) is \\([B]_t = t\\).\n\nRemark\nAlmost sure convergence is guaranteed if the sequence \\(\\{\\Delta_n\\}\\) satisfies the condition\n\\[\n  \\Delta_1 \\subset \\Delta_2 \\subset \\cdots \\subset \\Delta_n\n  \\subset \\cdots.\n\\]\nAlmost sure convergence is also guaranteed when \\(\\{\\Delta_n\\}\\) satisfies \\(\\displaystyle\\sum_{n=1}^\\infty \\| \\Delta_n \\| &lt; \\infty\\)."
  },
  {
    "objectID": "NSD_Lec02-StochCal_Summer2025.html#technical-note-convergence-in-lp",
    "href": "NSD_Lec02-StochCal_Summer2025.html#technical-note-convergence-in-lp",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "Technical note: Convergence in \\(L^p\\)",
    "text": "Technical note: Convergence in \\(L^p\\)\nA sequence of random variables \\(X_n\\) defined on the probability space \\((\\Omega,\\F,\\P)\\) is called convergent to \\(X\\) in \\(L^p\\) if\n\\[\n\\lim_{n\\to\\infty} \\|X_n - X\\|_p = 0 \\quad \\text{ or equivalently } \\quad \\lim_{n\\to\\infty} \\Eof{|X_n - X|^p} = 0\n\\]\nwhere \\(\\|X\\|_p = \\sqrt[p]{\\Eof{|X|^p}}\\) is the \\(L^p\\)-norm of the random variable \\(X\\).\n\nRemark\nRecall that we have the relationship among different types of convergence\n\\[\n\\begin{array}{ccccc}\n\\text{in } L^p & \\Rightarrow & \\text{in probability} & \\Rightarrow & \\text{in distribution or weakly} \\\\\n& & \\Uparrow & & \\\\\n& & \\text{almost surely}\n\\end{array}\n\\]"
  },
  {
    "objectID": "NSD_Lec02-StochCal_Summer2025.html#local-properties-of-brownian-paths",
    "href": "NSD_Lec02-StochCal_Summer2025.html#local-properties-of-brownian-paths",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "Local properties of Brownian paths",
    "text": "Local properties of Brownian paths\nLet \\(B_t\\) be a Brownian motion.\n\n\\(B_t\\) is locally Hölder continuous of order \\(\\alpha\\) for every \\(\\alpha &lt; \\frac12\\).\nThe Brownian paths are almost surely of infinite variation on any interval.\nThe Brownian paths are almost surely nowhere locally Hölder continuous of order \\(\\alpha\\) for \\(\\alpha &gt; \\frac12\\).\nLévy’s modulus of continuity. Let \\(h(t) = \\sqrt{2 t \\log(1/t) }\\). Then\n\n\\[\n\\P\\left[ \\mathop{\\overline{\\lim}}_{\\epsilon \\to 0} \\left( \\sup_{0\\leq t_1 &lt; t_2 \\leq 1, \\\\ t_2 - t_1 \\leq \\epsilon}\\frac{|B_{t_2} - B_{t_1}|}{h(\\epsilon)} \\right) = 1 \\right] = 1\n\\]"
  },
  {
    "objectID": "NSD_Lec02-StochCal_Summer2025.html#technical-note-lipschitz-and-hölder-continuity",
    "href": "NSD_Lec02-StochCal_Summer2025.html#technical-note-lipschitz-and-hölder-continuity",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "Technical note: Lipschitz and Hölder continuity",
    "text": "Technical note: Lipschitz and Hölder continuity\n\nDefinition (Lipschitz continuous)\nA function \\(f\\) is called Lipschitz or Lipschitz continuous on the interval \\([a,b]\\) if there exists a constant \\(L\\) such that\n\\[\n|f(t) - f(s)| \\leq L|t-s|\n\\]\nfor all \\(t,s \\in [a,b]\\).\n\n\nDefinition (Hölder continuous)\nA function \\(f\\) is called Hölder continuous of order \\(\\alpha\\) on the interval \\([a,b]\\) if there exists a constant \\(K\\) such that\n\\[\n|f(t) - f(s)| \\leq K|t-s|^\\alpha\n\\]\nfor all \\(t,s \\in [a,b]\\)."
  },
  {
    "objectID": "NSD_Lec02-StochCal_Summer2025.html#the-lévy-ciesielski-construction-of-brownian-motion",
    "href": "NSD_Lec02-StochCal_Summer2025.html#the-lévy-ciesielski-construction-of-brownian-motion",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "The Lévy-Ciesielski construction of Brownian motion",
    "text": "The Lévy-Ciesielski construction of Brownian motion\nLet \\(\\{\\psi_i\\}\\) be a complete orthonormal basis for \\(L^2[0,1]\\) and \\(\\xi_i\\), \\(i=1,2,\\cdots\\), an iid sequence of standard normal random variables defined on a probability space \\((\\Omega,\\F,\\P)\\). Define \\(\\displaystyle \\phi_i(t) = \\int_0^t \\psi_i(s) {\\rm d}s\\), for \\(t\\in[0,1]\\). Then the stochastic process \\(W\\) defined by\n\\[\n  W_t = \\sum_{i=1}^\\infty \\xi_i \\phi_i(t)\n\\]\nis a Brownian motion."
  },
  {
    "objectID": "NSD_Lec02-StochCal_Summer2025.html#paley-wiener-expansion-of-brownian-motion",
    "href": "NSD_Lec02-StochCal_Summer2025.html#paley-wiener-expansion-of-brownian-motion",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "Paley-Wiener expansion of Brownian motion",
    "text": "Paley-Wiener expansion of Brownian motion\nThe Paley-Wiener representation of a Brownian path in terms of a random Fourier series.\nLet \\(\\xi_n\\) be an iid sequence of standard normal variables. Then\n\\[\nB_t=\\xi_0 t+ \\sqrt{2}\\sum_{n=1}^\\infty\\xi_n\\frac{\\sin( n\\pi t)}{n \\pi}\n\\]\nand\n\\[\nB_t = \\sqrt{2} \\sum_{n=1}^\\infty \\xi_n \\frac{\\sin \\left(\\left(n - \\frac{1}{2}\\right) \\pi t\\right)}{ \\left(n - \\frac{1}{2}\\right) \\pi}\n\\]\nrepresent a Brownian motion on \\([0,1]\\).\n\n# import modules \nimport numpy as np \nimport matplotlib.pyplot as plt\nfrom numpy import exp, log, sqrt\nimport pandas as pd\nfrom scipy.stats import norm\nimport scipy.stats as ss\nimport seaborn as sns\n\n\n# set seed for reproducing the same result\nnp.random.seed(1414)\n\n# the following function plots the Brownian motion path by the Paley-Wiener expansion\ndef plotBM(N, color='blue', n_steps=200):\n    \"\"\"\n    Plot the Brownian motion path using the Paley-Wiener expansion.\n\n    Parameters:\n    N (int): Number of terms in the expansion.\n        That is, the number of random variables used.\n        That is, the ksi defined in the above section.\n    color (str): Color of the plot.\n    n_steps (int): Number of steps in the time grid.\n    \"\"\"\n    xi0, xi = norm.rvs(size=1)[0], norm.rvs(size=N)\n    n = np.arange(1, N+1)\n    W = lambda t: xi0*t + (sqrt(2)*sum(xi*np.sin(n*np.pi*t)/n/np.pi))*(N&gt;0)\n    t = np.linspace(0, 1, n_steps)\n    y = [W(x) for x in t]\n    plt.plot(t, y, color=color, label=f'$N$ = {N}')\n    plt.xlabel('$t$')\n    plt.ylabel('BM');    \n    return None\n\n# plot\nplt.figure(figsize=(12, 8))\nplt.subplot(2, 2, 1)\nplotBM(20)\nplt.legend()\n\nplt.subplot(2, 2, 2)\nplotBM(200, color='red')\nplt.legend()\n\nplt.subplot(2, 2, 3)\nplotBM(20_000, color='green')\nplt.legend();"
  },
  {
    "objectID": "NSD_Lec02-StochCal_Summer2025.html#donskers-invariance-principle",
    "href": "NSD_Lec02-StochCal_Summer2025.html#donskers-invariance-principle",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "Donsker’s invariance principle",
    "text": "Donsker’s invariance principle\n\nDonsker’s invariance principle is also referred to as the Donsker’s theorem.\n\nSuppose \\(\\{X_i\\}_{i=1}^\\infty\\) is an iid sequence of random variables with mean \\(0\\) and and variance \\(1\\). Let \\(S_n = \\sum_{i=1}^n X_i\\). Define the function \\(\\mathfrak{S}_n\\) of \\(t\\) by\n\\[\\begin{align*}\n\\mathfrak{S}_n(t) &= \\frac1{\\sqrt n}\\sum_{i=1}^n\\left[S_{i-1} + n \\left( t-\\frac{i-1}n \\right) X_i \\right]\\,\\1_{\\left(\\frac{i-1}n,\\frac in\\right]}(t).\n\\end{align*}\\]\n注: 设 \\(S_n(t)\\) 是某个离散随机过程(如简单随机游走)的归一化形式, 那么当步数 \\(n \\to \\infty\\) 时, 这个过程将弱收敛到布朗运动 \\(B(t)\\). 在数值模拟中, 我们通过高频率地取样并归一化, 让离散过程“逼近”布朗运动.\nIn fact, \\(\\mathfrak{S}_n\\) is simply the linear interpolation of the scaled random walk \\(\\left\\{\\frac{S_1}{\\sqrt n}, \\frac{S_2}{\\sqrt n}, \\cdots, \\frac{S_n}{\\sqrt n} \\right\\}\\).\n注: 我们只要求了 \\(\\Eof{X_i} = 0\\) 和 \\(\\Var[X_i] = 1\\), 而没有要求它是什么分布.\n注: 随机游走(Random Walk) 是指在每个时间点上随机选择一个方向(正或负)并移动一个单位长度的过程.\nThen, \\(\\mathfrak{S}_n\\Longrightarrow W\\) as \\(n\\to\\infty\\), where \\(W\\) denotes a Brownian motion.\nIn other words, as \\(n\\to\\infty\\), the linearly interpolated scaled random walk \\(\\mathfrak{S}_n\\) converges weakly to a Brownian motion."
  },
  {
    "objectID": "NSD_Lec02-StochCal_Summer2025.html#technical-note-weak-convergence-or-convergence-in-distribution",
    "href": "NSD_Lec02-StochCal_Summer2025.html#technical-note-weak-convergence-or-convergence-in-distribution",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "Technical note: Weak convergence or convergence in distribution",
    "text": "Technical note: Weak convergence or convergence in distribution\nA sequence of random variables \\(X_n\\) is called convergent weakly or convergent in distribution to \\(X\\) if it satisfies one of the following equivalent conditions.\n\n\\(\\displaystyle\\lim_{n\\to\\infty} \\phi_{X_n}(u) = \\phi_X(u)\\) for every \\(u\\), where \\(\\phi\\) is the characteristic function.\n\\(\\displaystyle\\lim_{n\\to\\infty} \\Eof{f(X_n)} = \\Eof{f(X)}\\) for all bounded continuous function \\(f\\)\n\\(\\displaystyle\\lim_{n\\to\\infty} F_n(x) = F(x)\\) for every \\(x\\) at which \\(F\\) is continuous. \\(F_n\\) and \\(F\\) are cdfs of \\(X_n\\) and \\(X\\) respectively.\n\n\nRemark\nAs opposed to the definition of convergence a.s., in \\(L^p\\), and in probability, in defining weak convergence, the random variables \\(X_n\\)’s and \\(X\\) need not to be defined on the same probability space.\n\n\nRecap: \\(t\\)-distribution\n\\(X \\sim {\\cal N}(0,1)\\), \\(Y \\sim \\chi^2(n)\\), then \\(\\displaystyle Z = \\frac{X}{\\sqrt{Y/n}} \\sim t(n)\\), here, \\(n\\) is the degree of freedom (df).\n\nExpectation: \\(\\Eof{Z} = 0\\) for \\(n &gt; 1\\).\nVariance: \\(\\displaystyle \\Var[Z] = \\frac{n}{n-2}\\) for \\(n &gt; 2\\).\n\n\n\nSimulate random walk\n\n# Simulate random walk\n#np.random.seed(0)\n\nn_steps, nu = 1_000_000, 11\n# Choose t distribution with df = nu\nX = ss.t.rvs(size=n_steps, df=nu)/sqrt(nu/(nu-2))\n# Choose n_steps iid random variables from t distribution with df = nu\n\nBM = np.append(0, X.cumsum())\n# It's a random walk, 0, S_1, S_2, ..., S_n.\n\nt = np.linspace(0, 1, n_steps+1)\nplt.figure(figsize=(10, 6))\n# plot random walk\nplt.subplot(1, 2, 1)\nplt.plot(t, BM, 'g')\nplt.xlabel('$t$', fontsize=18);\n# plot scaled random walk\nplt.subplot(1, 2, 2)\n#plt.plot(t, BM/n_steps)\nplt.plot(t, BM/np.sqrt(n_steps))\nplt.xlabel('$t$', fontsize=18);"
  },
  {
    "objectID": "NSD_Lec02-StochCal_Summer2025.html#simulation-of-brownian-motion",
    "href": "NSD_Lec02-StochCal_Summer2025.html#simulation-of-brownian-motion",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "Simulation of Brownian motion",
    "text": "Simulation of Brownian motion\n\n# Simulate BM by using the Donsker's invariance principle\n# number of samples, number of steps, terminal time\nn_sim, n_steps, T = 10_000, 1_000, 1  \ndt = T/n_steps\n\n# initialize the Brownians\n# n_sim: 几条布朗运动路径\n# n_steps+1: 每条路径的时间点个数\nB = np.zeros([n_sim, n_steps+1])\n\n# simulation step\nfor i in range(n_steps):\n    dB = norm.rvs(size=n_sim)\n#    dB = dB - dB.mean() # now dB has mean 0\n#    dB = dB/dB.std()  # now dB has variance 1\n    dB = np.sqrt(dt)*dB\n    B[:,i+1] = B[:,i] + dB \n\ndB 表示布朗运动增量, \\(\\Delta B \\sim {\\cal N}(0, \\Delta t)\\), 所以要乘以 dt 来构造满足这个条件的增量.\n上面注释的两行是为了创造一个 \\(\\Delta B \\sim {\\cal N}(0, 1)\\) 的增量. 但其实在大样本下, 自然已经接近标准正态分布了.\n最终, B 是一个大小为 (10000, 1001) 的矩阵, 表示 10,000 条布朗路径, 每条路径有 1001 个时间点.\n\n# plot\nt = np.arange(0, T+dt, dt)\n#t = np.linspace(0, T, n_steps+1)\nplt.figure(figsize=(10, 8))\n\n# sample path\npath = np.random.choice(n_sim)\nplt.subplot(2, 2, 1)\nplt.plot(t, B[path, :], label=f'sample path #{path}')\nplt.xlabel('$t$')\nplt.ylabel('$B_t$ sample path')\nplt.legend()\n\n# histograms\nplt.subplot(2, 2, 2)\ntime = 0.2\n# plot histogram of B at time t\nsns.histplot(B[:,t==time], bins=50, stat='density', label=f'$t={time}$')\n# plot histogram of B at time T\nsns.histplot(B[:,-1], bins=50, stat='density', color='orange', label=f'$t={T}$')\nx = np.linspace(B[:,-1].min(), B[:,-1].max(), 100)\nplt.plot(x, norm.pdf(x), 'r--', lw=1, label='normal pdf')\nplt.plot(x, norm.pdf(x, scale=sqrt(time)), 'y--', lw=1, label='normal pdf')\nplt.xlabel('$B$')\nplt.legend();\n\n# sample mean\nplt.subplot(2, 2, 3)\nplt.plot(t, B.mean(axis=0))\nplt.hlines(y=0, xmin=0, xmax=T, color='red', ls='dotted')\nplt.xlabel('$t$')\n\n# sample standard deviation\nplt.subplot(2, 2, 4)\nplt.plot(t, B.std(axis=0), label='sample std')\nplt.plot(t, np.sqrt(t), 'r--', label='sqrt t')\nplt.xlabel('$t$')\nplt.legend();"
  },
  {
    "objectID": "NSD_Lec02-StochCal_Summer2025.html#brownian-motion-with-drift",
    "href": "NSD_Lec02-StochCal_Summer2025.html#brownian-motion-with-drift",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "Brownian motion with drift",
    "text": "Brownian motion with drift\nLet \\((\\Omega,\\F_t,\\P)\\) be a filtered probability space and \\(B_t\\) a Brownian motion on \\(\\Omega\\). A stochastic process \\(X\\) of the form\n\\[\nX_t = x + B_t + \\int_0^t \\mu_s \\text{d}s \\quad \\Longleftrightarrow \\quad \\text{d}X_t = \\text{d}B_t + \\mu_t \\text{d}t\n\\]\nis called a Brownian motion with drift \\(\\mu_t\\), where \\(\\mu\\) is adapted to the filtration \\(\\F_t\\).\n\\(\\mu_t\\) is the velocity of the drift at time \\(t\\) and \\(x\\) is the initial value of the process at time \\(t=0\\).\n\nRemark\n\n\\(X_t\\) is a Gaussian process if \\(\\mu_t\\) is deterministic. Apparently, the mean function is \\(\\displaystyle \\Eof{X_t} = x + \\int_0^t \\mu_s \\text{d}s\\) and the covariance function \\(\\gamma(t,s) = \\cov(X_t,X_s) = \\min\\{t,s\\}\\).\nWe can always transform a Brownian motion with drift into a standard Brownian motion by change of the underlying probability measure so long as the drift \\(\\mu_t\\) satisfies certain conditions, say, bounded."
  },
  {
    "objectID": "NSD_Lec02-StochCal_Summer2025.html#wiener-integral",
    "href": "NSD_Lec02-StochCal_Summer2025.html#wiener-integral",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "Wiener integral",
    "text": "Wiener integral\n\nLet \\(f\\) be a (deterministic) step function defined by \\(f = \\sum_{i=1}^n a_i \\1_{[t_{i-1}, t_i)}\\), where \\(t_0 = a\\) and \\(t_n = b\\), \\(a_i \\in \\R\\). The Wiener integral \\(I(f)\\) of \\(f\\) is defined by\n\\[\n  I(f) = \\int_a^b f(t) \\text{d}B_t = \\sum_{i=1}^n a_i \\Delta B_{t_i}, \\quad \\Delta B_{t_i} = B_{t_i} - B_{t_{i-1}}.\n  \\]\nLet \\(f\\in L^2[a,b]\\) and \\(f_n\\) be a sequence of step functions such that \\(f_n \\to f\\) in \\(L^2[a,b]\\). The Wiener integral \\(I(f)\\) of \\(f\\) is defined by\n\\[\n  I(f) = \\int_a^b f(t) {\\rm d}B_t = \\lim_{n\\to\\infty} \\int_a^b f_n(t) {\\rm d}B_t, \\quad \\text{ in } L^2(\\Omega).\n  \\]\n\nA technical issue here: Is \\(I(f)\\) well-defined?\n注: \\(I(f)\\) 是一个随机变量, 因为 \\({\\rm d} B_t\\) 是一个正态分布的随机变量."
  },
  {
    "objectID": "NSD_Lec02-StochCal_Summer2025.html#wiener-integral-is-normally-distributed",
    "href": "NSD_Lec02-StochCal_Summer2025.html#wiener-integral-is-normally-distributed",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "Wiener integral is normally distributed",
    "text": "Wiener integral is normally distributed\n\nTheorem\nFor each \\(f\\in L^2[a,b]\\), the Wiener integral \\(\\displaystyle \\int_a^b f(t)\\text{d}B_t\\) is a Gaussian random variable with mean 0 and variance \\(\\displaystyle \\|f\\|_2^2 = \\int_a^b f^2(t)\\text{d}t\\). In short,\n\\[\n   \\int_a^b f(s) \\text{d} B_s \\sim N(0,\\|f\\|_2^2).\n\\]\n\nIn particular, recall that if the integrand \\(f\\) is the step function \\(f(t) = \\sum_{i=1}^n a_i \\1_{[t_{i-1},t_i)}(t)\\), apparently the Wiener integral \\(I(f)\\) of \\(f\\) is normally distributed\n\\[\n  I(f) = \\sum_{i=1}^n a_i \\Delta B_i \\sim N\\left(0,\\sum_{i=1}^n a_i^2 \\Delta t_i \\right)\n  \\]\nsince the \\(\\Delta B_i\\)’s are independent normal random variables.\nThe proof for general \\(f\\in L^2[a,b]\\) is based on limiting process.\n\n\n\nExample\n\\[\n  \\int_0^t s \\text{d}B_s \\sim N\\left(0,\\frac{t^3}3\\right)\n\\]\n\n\nCorollary\nIf \\(f,g\\in L^2[a,b]\\), then\n\\[\n  \\E[I(f)I(g)] = \\E\\left[ \\int_a^b f(s) \\text{d}B_s \\int_a^b g(s) \\text{d}B_s\\right] = \\int_a^b f(t)g(t) \\text{d}t.\n\\]\nProof: 我们可以发现 \\(\\Eof{{\\rm d}B_s {\\rm d}B_t} = 0 (s\\neq t)\\), \\(\\Eof{({\\rm d}B_t)^2} = \\Var[{\\rm d}B_t] = {\\rm d} t\\). (这是根据布朗运动的定义, 以及布朗运动的独立增量性质.)\nThus, the Wiener integral \\(I:L^2[a,b] \\to L^2(\\Omega)\\) is an isometry(等距). In particular, if \\(f\\) and \\(g\\) are orthogonal, i.e., \\(\\displaystyle \\int_a^b f g \\text{d}x = 0\\), then the Gaussian random variables \\(I(f)\\) and \\(I(g)\\) are independent."
  },
  {
    "objectID": "NSD_Lec02-StochCal_Summer2025.html#properties-of-wiener-integral",
    "href": "NSD_Lec02-StochCal_Summer2025.html#properties-of-wiener-integral",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "Properties of Wiener integral",
    "text": "Properties of Wiener integral\nLet \\(f\\) and \\(g\\) be deterministic \\(L^2[a,b]\\) functions, \\(\\alpha\\) and \\(\\beta\\) are constants. Then\n\n\\(\\displaystyle \\int_a^b \\left[\\alpha f(t) + \\beta g(t)\\right] {\\rm d}B_t = \\alpha \\int_a^b f(t) {\\rm d}B_t + \\beta \\int_a^b g(t) {\\rm d}B_t\\).\n\\(\\displaystyle \\int_a^b f(t) {\\rm d}B_t = \\int_a^c f(t) {\\rm d}B_t+ \\int_c^b f(t) {\\rm d}B_t\\), for \\(c\\in[a,b]\\).\n\n\nIntegration by parts formula\nLet \\(f\\) be a continuous function of bounded variation. Then almost surely\n\\[\n  \\int_a^b f(t) \\d B_t = f(t) B_t |_a^b - \\int_a^b B_t \\d f(t).\n\\]\n\nNote that the integral on the left hand side is in the sense of Wiener, whereas on the right hand side is in the sense of Riemann-Stietjes.\n\n\n\nExample\nDetermine the distribution of the random variable \\(\\displaystyle \\int_0^1 B_t \\d t\\).\n解答: \\[\\begin{align*}\n\\int_0^1 B_t \\d t &= t B_t \\Big|_0^1 - \\int_0^1 t \\d B_t = B_1 - \\int_0^1 t \\d B_t.\n\\end{align*}\\] 那么再根据 Wiener Integral 是正态分布的, 且 Variance 为 \\(\\| f \\|^2\\), 我们知道:\n\n\\(\\displaystyle \\int_0^1 t \\d B_t \\sim N(0, \\frac{1}{3})\\)\n\\(\\displaystyle B_1 \\sim N(0,1)\\)\n\n因此 \\(\\displaystyle \\int_0^1 B_t \\d t \\sim N\\left(0, 1 + \\frac{1}{3}\\right) = N\\left(0, \\frac{4}{3}\\right)\\). (布朗运动增量独立.)"
  },
  {
    "objectID": "NSD_Lec02-StochCal_Summer2025.html#wiener-integral-defines-a-continuous-martingale",
    "href": "NSD_Lec02-StochCal_Summer2025.html#wiener-integral-defines-a-continuous-martingale",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "Wiener integral defines a continuous martingale",
    "text": "Wiener integral defines a continuous martingale\nLet \\(f\\in L^2[a,b]\\). Then the stochastic process \\(M_t\\) obtained through Wiener integral\n\\[\n  M_t = \\int_a^t f(s) \\d B_s, \\quad a \\leq t \\leq b,\n\\]\nis a martingale with respect to \\(\\F_s = \\sigma(B_s; s \\leq t)\\).\n注: 过滤 (filtration)是一组随时间“增长”的 \\(\\sigma\\)-代数, 用来描述我们在每个时间点所知道的信息. 也就是一族集合 \\(\\{\\cF_t\\}_{t \\geq 0}\\), 其中: \\[\n\\cF_s \\subseteq \\cF_t, \\quad \\text{ when } s\\leq t.\n\\] 时间越往后, 信息越多.\n\nDon’t be confused with a continuous time martingale and a continuous martinagle.\nSince Wiener integral defines a Gaussian process, continuity of the process can be obtained by applying Kolmogorov’s continuity criterion.\n\n\nTechnical note: martingale conditions\nTo show if the process \\(M_t\\) is a martingale, we need to verify the three defining conditions\n\n\\(M_t\\) is adapted\n\\(M_t\\) is integrable for every \\(t\\)\nFor every \\(s &lt; t\\), \\(\\Eof{M_t | \\F_s} = M_s\\) almost surely\n\n注: Martingale 说明了当前的期望值就是将来的条件期望, 没有“预测性”或“趋势”."
  },
  {
    "objectID": "NSD_Lec02-StochCal_Summer2025.html#an-illustrative-example-for-ito-integral",
    "href": "NSD_Lec02-StochCal_Summer2025.html#an-illustrative-example-for-ito-integral",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "An illustrative example for Ito integral",
    "text": "An illustrative example for Ito integral\nLet’s start with defining the simple integral as\n\\[\n  \\int_0^t B_s \\d B_s.\n\\]\nAs in the theory of Riemann-Stieltjes integral, we shall start with partitioning the interval \\([0,t]\\) into, say, \\(n\\) subintervals. Within each subinterval, we pick a point and evaluate the integrand at that point, multiply that value by the increment of the integrator in that subinterval. Then we sum up the results from each subinterval and take limit as the mesh of the partition approaches zero. Possible choices for selecting points from each subinterval may be, denoting \\(\\Delta B_{t_k} = B_{t_k} - B_{t_{k-1}}\\):\n\nThe right point rule: \\[\n  R_n = \\sum_{k=1}^n B_{t_k} \\Delta B_{t_k}\n  \\]\nThe left point rule: \\[\n  L_n = \\sum_{k=1}^n B_{t_{k-1}} \\Delta B_{t_k}\n  \\]\nThe midpoint rule: \\[\n  M_n = \\sum_{k=1}^n B_{t_*} \\Delta B_{t_k}, \\quad \\text{ where } t_* = \\frac{t_k + t_{k-1}}2\n  \\]"
  },
  {
    "objectID": "NSD_Lec02-StochCal_Summer2025.html#which-rule-rules",
    "href": "NSD_Lec02-StochCal_Summer2025.html#which-rule-rules",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "Which rule rules?",
    "text": "Which rule rules?\nQuestion: Which rule yields convergent integral? in what sense? We knew that it can’t be pathwise because the integrator, in this case the Brownian motion, is not of finite variation (because it has nonzero second variation) almost surely.\nNote that the following identities hold. \\[\\begin{align*}\n  && R_n - L_n = \\sum_{k=1}^n \\left( \\Delta B_{t_k} \\right)^2,  \\qquad\n  R_n + L_n = \\sum_{k=1}^n \\Delta B_{t_k}^2 = B_t^2.  \\\\\n\\end{align*}\\] Hence, \\[\\begin{align*}\n  && R_n = \\frac{B_t^2}2 + \\frac12 \\sum_{k=1}^n \\left( \\Delta B_{t_k} \\right)^2,  \\qquad\n   L_n = \\frac{B_t^2}2 - \\frac12 \\sum_{k=1}^n \\left( \\Delta B_{t_k} \\right)^2.\n\\end{align*}\\] Notice that the first term in both expressions is independent of partitions and the second term, as we have seen in previous lecture, will converge to the quadratic variation of Brownian motion in \\(L^2\\) as the mesh approaches zero! Consequently,\n\\[\\begin{align*}\n  & \\lim_{\\|\\Pi_n\\|\\to0} R_n = \\frac{B_t^2}2 + \\frac t2,  \\qquad\n   \\lim_{\\|\\Pi_n\\|\\to0} L_n = \\frac{B_t^2}2 - \\frac t2.\n\\end{align*}\\]\nSo we learnt from this simple example that\n\nThe right point rule and the left end point rule yield different “integrals”.\nThe difference between the “right integral” and the “left integral” is exactly the quadratic variation.\nThe convergence is in \\(L^2\\) sense.\n\n\nRemark\n\nWe need to stick with one specific rule in order to have convergence.\nIto picked the left end point rule because of adaptivity and martingality.\n\\(L_n\\) is a martingale whereas \\(R_n\\) isn’t.\nThe midpoint rule leads to the Stratonovich integral."
  },
  {
    "objectID": "NSD_Lec02-StochCal_Summer2025.html#simulation-of-stochastic-integral-left-endpoint-rule",
    "href": "NSD_Lec02-StochCal_Summer2025.html#simulation-of-stochastic-integral-left-endpoint-rule",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "Simulation of stochastic integral: left endpoint rule",
    "text": "Simulation of stochastic integral: left endpoint rule\n\n# Simulate the stochastic integral int f(B) dB from 0 to t, for t in [0,1]\n# Demonstrate the effect of Ito correction/term \n\n# number of samples, number of steps, terminal time\nn_sim, n_steps, T = 10_000, 100, 1   \n\ndt = T/n_steps\n\nB = np.zeros([n_sim, n_steps+1])\ndB = np.zeros([n_sim, n_steps+1])\n\n# Simulate Browian paths\nfor i in range(n_steps):\n    db = norm.rvs(size=n_sim)\n    db = db - db.mean() # now db has mean 0\n    db = db/db.std() # now db has variance 1\n    dB[:,i] = np.sqrt(dt)*db\n    B[:,i+1] = B[:,i] + dB[:,i]\n\n# Calculate the (discretized) stochastic integral using left endpoints\nf = lambda x: x\ndX = f(B)*dB\nX = dX.cumsum(axis=1)\n\n# plots\nt = np.arange(0, T+dt, dt)\nplt.figure(figsize=(12, 8))\n\n# evolution of mean\nplt.subplot(2, 2, 1)\nplt.plot(t, X.mean(axis=0))\nplt.xlabel('$t$')\nplt.ylabel('sample mean', fontsize=12)\n    \n# evolution of variance\nplt.subplot(2, 2, 2)\nplt.plot(t,X.var(axis=0))\nplt.xlabel('$t$')\nplt.ylabel('sample variance', fontsize=12)\n    \n# histogram at terminal time\nplt.subplot(2, 2, 3)\nsns.histplot(X[:,-1], bins=50, stat='density', color='green', element='step');"
  },
  {
    "objectID": "NSD_Lec02-StochCal_Summer2025.html#simulation-of-stochastic-integral-right-endpoint-rule",
    "href": "NSD_Lec02-StochCal_Summer2025.html#simulation-of-stochastic-integral-right-endpoint-rule",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "Simulation of stochastic integral: right endpoint rule",
    "text": "Simulation of stochastic integral: right endpoint rule\n\n# What happens if we use right endpoints? \n\n# Calculate the (discretized) stochastic integral using right endpoints\nB = B[:,1:]\ndB = dB[:,:-1]\ndX = f(B)*dB\nX = dX.cumsum(axis=1)\n\n# plots\nt = np.arange(0, T, dt)\nplt.figure(figsize=(12, 8))\n\n# evolution of mean\nplt.subplot(2, 2, 1)\nplt.plot(t,X.mean(axis=0))\nplt.xlabel('$t$')\nplt.ylabel('sample mean', fontsize=12)\n    \n# evolution of variance\nplt.subplot(2, 2, 2)\nplt.plot(t,X.var(axis=0))\nplt.xlabel('$t$')\nplt.ylabel('sample variance', fontsize=12)\n    \n# histogram at terminal time\nplt.subplot(2, 2, 3)\nsns.histplot(X[:,-1], bins=50, stat='density', color='green');"
  },
  {
    "objectID": "NSD_Lec02-StochCal_Summer2025.html#伊藤-清-先生-itô-kiyoshi-sensei",
    "href": "NSD_Lec02-StochCal_Summer2025.html#伊藤-清-先生-itô-kiyoshi-sensei",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "伊藤 清 先生 (Itô, Kiyoshi sensei)",
    "text": "伊藤 清 先生 (Itô, Kiyoshi sensei)\n\n\n\nCourtesy: Photo from Wikipedia"
  },
  {
    "objectID": "NSD_Lec02-StochCal_Summer2025.html#ito-integral-of-simple-processes",
    "href": "NSD_Lec02-StochCal_Summer2025.html#ito-integral-of-simple-processes",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "Ito integral of simple processes",
    "text": "Ito integral of simple processes\n\nDefinition (simple process)\nA process \\(\\varphi_t\\) is called simple if it is of the form\n\\[\n\\varphi_t(\\omega) = \\sum_{k=1}^n \\xi_{k-1}(\\omega) \\1_{[t_{k-1},t_k)}(t),\n\\]\nwhere \\(\\xi_k \\in \\F_{t_k}\\) for \\(k=0,\\cdots,n\\).\n\nBasically, a simple process is simply a step function with random coefficients that are measurable with respect to the left endpoints.\nSimple process is defined as such for mimicking a) the step functions in the Wiener integral and b) the left endpoint rule in the Riemann integral.\nThe left endpoint measurability is key to the martingality of Ito integral, as we expected.\n\n注: 和 Wiener Integral 相比, 它把被积函数 \\(\\varphi_t\\) 也随机化了.\n\n\nDefinition (Ito integral of a simple process)\nThe stochastic integral of a simple process \\(\\varphi_t\\) with respect to Brownian motion \\(B_t\\) over \\([0,T]\\) is defined by\n\\[\n  \\int_0^T \\varphi_t \\d B_t = \\sum_{k=1}^n \\xi_{k-1} \\Delta B_{t_k}, \\quad \\text{ where } \\Delta B_{t_k} = B_{t_k} - B_{t_{k-1}}.\n\\]"
  },
  {
    "objectID": "NSD_Lec02-StochCal_Summer2025.html#integrand-for-ito-integral",
    "href": "NSD_Lec02-StochCal_Summer2025.html#integrand-for-ito-integral",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "Integrand for Ito integral",
    "text": "Integrand for Ito integral\n\nDefinition\nWe will use \\(L^2_{ad}(\\Omega\\times[a,b])\\) to denote the space of all stochastic processes \\(\\varphi_t(\\omega)\\), \\(a\\leq t \\leq b\\), satisfying\n\n\\(\\varphi_t\\) is adapted to the filtration \\(\\F_t\\).\n\\(\\displaystyle \\int_a^b \\Eof{|\\varphi_t|^2} \\d t &lt; \\infty\\).\n\nIn other words, \\(\\varphi_t\\) is adatped and in \\(L^2(\\Omega\\times[a,b])\\).  Note that, for notational simplicity, we usually omit the reference to the sample space \\(\\Omega\\) and deonte the space as \\(L^2_{ad}[a,b]\\).\n\n\nLemma\nAny \\(L_{ad}^2\\) process is the \\(L^2\\) limit of a sequence of simple processes. Precisely, let \\(\\varphi_t \\in L^2_{\\rm ad}([a,b])\\). Then there exists a sequence of simple processes \\(\\{\\varphi^{(n)}_t\\}\\) in \\(L^2_{\\rm ad}([a,b])\\) such that\n\\[\n  \\lim_{n\\to\\infty} \\Eof{\\int_a^b |\\varphi^{(n)}_t - \\varphi_t|^2 \\d t} = 0.\n\\]\nIn other words, \\(\\varphi^{(n)}_t \\to \\varphi_t\\) in \\(L^2_{\\rm ad}([a,b])\\)."
  },
  {
    "objectID": "NSD_Lec02-StochCal_Summer2025.html#properties-of-ito-integral",
    "href": "NSD_Lec02-StochCal_Summer2025.html#properties-of-ito-integral",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "Properties of Ito integral",
    "text": "Properties of Ito integral\nLet \\(\\varphi \\in L^2_{ad}\\) and, for \\(t \\in [0,T]\\),\n\\[\n  X_t = \\int_0^t \\varphi_s \\d B_s\n\\]\nbe the stochastic integral of \\(\\varphi_t\\) with respect to Brownian motion \\(B_t\\) up to time \\(t\\). Then \\(X_t\\) has the following properties.\n\nAdaptivity: \\(X_t \\in \\F_t\\) for each \\(t\\).\nMartingality: \\(X_t\\) is a martingale.\nIto isometry: \\[\n      \\E[X_t^2] = \\Eof{\\int_0^t \\varphi_s^2 \\d s}\\; \\leftrightsquigarrow \\; \\Eof{\\left[\\int_0^t \\varphi_s \\d B_s\\right]^2} = \\int_0^t \\Eof{\\varphi_s^2} \\d s.\n  \\]\nQuadratic variation: \\(\\displaystyle [X]_t = \\int_0^t \\varphi_s^2 {\\rm d} s \\leftrightsquigarrow d[X]_t = \\varphi_t^2 \\d t\\).\nContinuity: \\(X_t\\) is continuous in \\(t\\) a.s.\nLinearity: Let \\(\\psi_t\\) be another adapted process with \\(\\displaystyle \\Eof{\\int_0^T \\psi_t^2 \\d t} &lt; \\infty\\) and \\(\\alpha,\\beta \\in \\R\\). Then\n\\[\n  \\int_0^t (\\alpha \\varphi_s + \\beta \\psi_s) \\d B_s = \\alpha \\int_0^t \\varphi_s \\d B_s + \\beta \\int_0^t \\psi_s \\d B_s.\n  \\]"
  },
  {
    "objectID": "NSD_Lec02-StochCal_Summer2025.html#ito-processes",
    "href": "NSD_Lec02-StochCal_Summer2025.html#ito-processes",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "Ito processes",
    "text": "Ito processes\n\nDefinition\nAn adapted process \\(X_t\\) is called an Ito process if it is of the form\n\\[\n  X_t = x + \\int_0^t \\sigma_s \\d B_s + \\int_0^t b_s \\d s,\n\\]\nwhere \\(\\sigma_t\\) and \\(b_s\\) are adapted processes. We also write it in differential form as\n\\[\n  \\d X_t = \\sigma_t \\d B_t + b_t \\d t, \\quad \\text{with initial condition } X_0 = x.\n\\]\nThe coefficient \\(b_t\\) is referred to as the drift (term) and \\(\\sigma_t\\) as the diffusion (term) of the Ito process \\(X_t\\).\n注: 非正式理解 \\[\nX_t = \\text{初始值} + \\text{“随机扰动”} + \\text{“确定趋势”}\n\\]\n注: \\(\\sigma_t\\), \\(b_t\\) 是适应的过程 (adapted process). 这意味着它们在每一时刻 \\(t\\) 的值, 只能依赖于当前或过去的信息, 不能知道未来.\n\n\nLemma\nThe quadratic variation of the Ito process \\(X_t\\) is\n\\[\n  [X]_t = \\int_0^t \\sigma_s^2 \\d s \\quad \\leftrightsquigarrow \\quad \\d [X]_t = \\sigma_t^2 \\d t.\n\\]\nNote that\n\nthough the quadratic variation of Brownian motion is deterministic (recall \\([B]_t = t\\) a.s.), in general the quadratic variation of an Ito process is stochastic;\nthe proof is very similar to that of Brownian and is left as an exercise."
  },
  {
    "objectID": "NSD_Lec02-StochCal_Summer2025.html#ito-integral-with-respect-to-ito-processes",
    "href": "NSD_Lec02-StochCal_Summer2025.html#ito-integral-with-respect-to-ito-processes",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "Ito integral with respect to Ito processes",
    "text": "Ito integral with respect to Ito processes\nLet \\(X_t\\) be an Ito process with drift \\(b_t\\) and diffusion \\(\\sigma_t\\), i.e., \\(X_t\\) is defined by\n\\[\n  X_t = x + \\int_0^t \\sigma_s \\d B_s + \\int_0^t b_s \\d s \\quad \\leftrightsquigarrow \\quad \\d X_t = \\sigma_t \\d B_t + b_t \\d t, \\; X_0 = x.\n\\]\nand \\(\\varphi_t\\) be an adapted process. We define the stochastic integral of \\(\\varphi_t\\) with respect to \\(X_t\\) as\n\\[\n  \\int_0^t \\varphi_s \\d X_s = \\int_0^t \\varphi_s \\sigma_s \\d B_s + \\int_0^t \\varphi_s b_s \\d s\n\\]\nprovided the integrals on the right hand side are defined."
  },
  {
    "objectID": "NSD_Lec02-StochCal_Summer2025.html#itos-formula-for-brownian-motion",
    "href": "NSD_Lec02-StochCal_Summer2025.html#itos-formula-for-brownian-motion",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "Ito’s formula for Brownian motion",
    "text": "Ito’s formula for Brownian motion\n\nTheorem\nLet \\(f(t,x)\\) be a function with continuous partial derivatives \\(f_t\\), \\(f_x\\), and \\(f_{xx}\\). Let \\(W_t = W_0 + B_t\\) be a Brownian motion starting at \\(W_0\\) (nonrandom). Then, for every \\(T \\geq 0\\),\n\\[\n  f(T,W_T) - f(0,W_0) = \\int_0^T f_x(t,W_t) \\d W_t + \\int_0^T \\left[f_t(t,W_t) + \\frac12 f_{xx}(t,W_t) \\right] \\d t.\n\\]\nOr equivalently in differential form\n\\[\n  \\d f(t,W_t) = f_x(t,W_t) \\d W_t + \\left[ f_t(t,W_t) + \\frac12 f_{xx}(t,W_t) \\right] \\d t.\n\\]\n\n\nRemark\nThe idea is that we Taylor expand \\(f(t,W_t)\\) to second order then formally apply the following rule:\n\\[\n(\\d B_t)^2 \\rightsquigarrow \\d t, \\quad (\\d t)^2 \\rightsquigarrow 0, \\quad \\d B_t \\d t \\rightsquigarrow 0.\n\\]\n注: Itô 引理其实说明了, 从 \\(f(0, W_0)\\) 到 \\(f(T, W_T)\\) 的变化有两个来源:\n\n随着布朗运动波动的部分, \\(\\displaystyle \\int f_x \\d W_t\\).\n时间推移和布朗运动“扩散”的影响, \\(\\displaystyle \\int \\left[ f_t + \\frac12 f_{xx} \\right] \\d t\\).\n\n注: 我们可以把 Itô 引理看成一个“随机链式法则”.\n\n\nRecap: 普通链式法则\n\\[\n\\d f = f_t \\d t + f_x \\d x.\n\\]\n推导过程:\n首先, 对 \\(f\\) 进行泰勒展开: \\[\\begin{align*}\nf(t+\\d t, x+\\d x) - f(t,x) =\\; &f_t \\d t + f_x \\d x  \\\\\n&+ \\frac12 f_{xx} (\\d x)^2 + \\frac12 f_{tt} (\\d t)^2 + f_{tx} \\d t \\d x + ...\n\\end{align*}\\]\n下面的二次项和高阶项都可以忽略, 因为它们的量级比 \\(\\d t\\) 和 \\(\\d x\\) 小得多.\n\n\nItô 引理推导\n同理, 我们进行泰勒展开: \\[\\begin{align*}\nf(t+\\d t, W_t +\\d W_t) - f(t,W_t) =\\; &f_t \\d t + f_x \\d W_t  \\\\\n&+ \\frac12 f_{xx} (\\d W_t)^2 + \\frac12 f_{tt} (\\d t)^2 + f_{tx} \\d t \\d W_t + ...\n\\end{align*}\\] 现在根据 \\((\\d B_t)^2 \\rightsquigarrow \\d t\\)(这是因为 Quadratic Variation of Brownian Motion is \\([B]_t = t\\), 那么 \\([\\d B_t]_t = \\d t\\)), 而剩下的都趋向 \\(0\\), 我们就得到了 Itô 引理."
  },
  {
    "objectID": "NSD_Lec02-StochCal_Summer2025.html#itos-formula-for-ito-process",
    "href": "NSD_Lec02-StochCal_Summer2025.html#itos-formula-for-ito-process",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "Ito’s formula for Ito process",
    "text": "Ito’s formula for Ito process\nLet \\(f(t,x)\\) be a function with continuous partial derivatives \\(f_t\\), \\(f_x\\), and \\(f_{xx}\\). Then for every \\(T \\geq 0\\), \\[\\begin{align*}\n  f(T,X_T) - f(0,x) &= \\int_0^T f_t(t,X_t) \\d t + \\int_0^T f_x(t,X_t) \\d X_t + \\frac12 \\int_0^T f_{xx}(t,X_t) \\d [X]_t  \\\\\n  &= \\int_0^T f_x(t,X_t) \\sigma_t \\d B_t + \\int_0^T \\left[f_t + \\frac{\\sigma_t^2}2 f_{xx} + b_t f_x \\right] \\d t.\n\\end{align*}\\] Or in differential form\n\\[\\begin{align*}\n  \\d f(t,X_t) &= f_t(t,X_t) \\d t + f_x(t,X_t) \\d X_t + \\frac12 f_{xx}(t,X_t) \\d [X]_t   \\\\\n  &= \\sigma_t f_x \\d B_t + \\left[ f_t + \\frac{\\sigma_t^2}{2} f_{xx} + b_t f_x \\right] \\d t\n\\end{align*}\\]\n\nRemark\n\nIto’s formula naturally decomposes \\(f(t,X_t)\\) into a drift/finite variation part plus a diffusion/martingale part; reminiscent of the Doob decomposition. Processes consist of a finite variation part and a martingale part are also referred to as semi-martingales.\nNote that the second order differential operator \\(\\displaystyle \\frac{\\sigma_t^2}2 \\p_x^2 + b_t \\p_x\\) in the drift part is the infinitesimal generator of the process \\(X_t\\).\n\n\n\n推导\n\\(f(t, X_t)\\) 的增量为:\n\\[\\begin{align*}\n\\mathrm{d}f(t, X_t)\n&= f_t(t, X_t) \\, \\mathrm{d}t + f_x(t, X_t) \\, \\mathrm{d}X_t + \\frac{1}{2} f_{xx}(t, X_t) \\, (\\mathrm{d}X_t)^2\n\\end{align*}\\]\n注意这里我们只保留到二阶项, 是因为 \\((\\mathrm{d}X_t)^2\\) 是一阶(因为会出现 \\((\\mathrm{d}B_t)^2 = \\mathrm{d}t\\)), 而更高阶项如 \\((\\mathrm{d}t)^2\\)、\\(\\mathrm{d}t \\mathrm{d}B_t\\) 等都趋于 \\(0\\).\n接着代入 \\(\\mathrm{d}X_t\\). 由定义, Itô 过程满足:\n\\[\n\\mathrm{d}X_t = \\sigma_t \\mathrm{d}B_t + b_t \\mathrm{d}t.\n\\]\n我们代入 \\(\\mathrm{d}X_t\\) 得:\n\n一阶项: \\[\nf_x(t,X_t)\\mathrm{d}X_t = f_x(t,X_t)(\\sigma_t \\mathrm{d}B_t + b_t \\mathrm{d}t)\n\\]\n二阶项: 我们来计算 \\((\\mathrm{d}X_t)^2\\):\n\n\\[\n(\\mathrm{d}X_t)^2 = (\\sigma_t \\mathrm{d}B_t + b_t \\mathrm{d}t)^2 = \\sigma_t^2 (\\mathrm{d}B_t)^2 + 2\\sigma_t b_t \\mathrm{d}B_t \\mathrm{d}t + b_t^2 (\\mathrm{d}t)^2\n\\]\n根据 Itô 规则:\n\\[\n(\\d B_t)^2 \\rightsquigarrow \\d t, \\quad (\\d t)^2 \\rightsquigarrow 0, \\quad \\d B_t \\d t \\rightsquigarrow 0.\n\\]\n所以有:\n\\[\n(\\mathrm{d}X_t)^2 = \\sigma_t^2 \\, \\mathrm{d}t\n\\]\n最后代入 Taylor 展开式, 合并所有项:\n\\[\\begin{align*}\n\\mathrm{d}f(t, X_t)\n&= f_t(t, X_t)\\, \\mathrm{d}t\n+ f_x(t, X_t)\\, (\\sigma_t \\mathrm{d}B_t + b_t \\mathrm{d}t)\n+ \\frac{1}{2} f_{xx}(t, X_t) \\cdot \\sigma_t^2 \\mathrm{d}t \\\\\n&= f_x \\sigma_t \\, \\mathrm{d}B_t + \\left( f_t + b_t f_x + \\frac{1}{2} \\sigma_t^2 f_{xx} \\right) \\mathrm{d}t\n\\end{align*}\\]\n\\[\n\\boxed{\n\\mathrm{d}f(t, X_t) = f_x(t,X_t) \\sigma_t \\, \\mathrm{d}B_t\n+ \\left(f_t(t,X_t) + b_t f_x(t,X_t) + \\frac{1}{2} \\sigma_t^2 f_{xx}(t,X_t) \\right)\\mathrm{d}t\n}\n\\]"
  },
  {
    "objectID": "NSD_Lec02-StochCal_Summer2025.html#review-fundamental-theorem-of-calculus-and-taylors-theorem",
    "href": "NSD_Lec02-StochCal_Summer2025.html#review-fundamental-theorem-of-calculus-and-taylors-theorem",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "Review: Fundamental theorem of calculus and Taylor’s theorem",
    "text": "Review: Fundamental theorem of calculus and Taylor’s theorem\n\nFundamental theorem of calculus\nLet \\(f\\) be a continuously differentiable function. Then \\[\nf(y) - f(x) = \\int_x^y f'(\\xi) \\d\\xi.\n\\]\n\n\nTaylor’s theorem\nFor a second differentiable function \\(f\\), there exists some \\(\\xi\\) between \\(y\\) and \\(x\\) such that\n\\[\\begin{align*}\n&& f(y) - f(x) = f'(x) (y - x) + \\frac{f''(\\xi)}2 (y-x)^2.\n\\end{align*}\\]\nNotice that the equation is exact, however in general it is not possible to specify what \\(\\xi\\) is.\n\n\nTaylor’s expansion up to 2nd order with 2 variables\nThe Taylor expansion of \\(f\\) (expanded about \\((x,t)=(a,b)\\)) is:\n\\[\\begin{align*}\nf(x,t) = &f(a,b) + f_x(a,b)(x-a) + f_t(a,b)(t-b) \\\\\n&+ \\frac{f_{xx}(a,b)}2 (x-a)^2 + f_{xt}(a,b)(x-a)(t-b) + \\frac{f_{tt}(a,b)}2 (t-b)^2 + \\cdots\n\\end{align*}\\]"
  },
  {
    "objectID": "NSD_Lec02-StochCal_Summer2025.html#applications-of-itos-formula-i-evaluating-stochastic-integral",
    "href": "NSD_Lec02-StochCal_Summer2025.html#applications-of-itos-formula-i-evaluating-stochastic-integral",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "Applications of Ito’s formula I: Evaluating stochastic integral",
    "text": "Applications of Ito’s formula I: Evaluating stochastic integral\nIn classical calculus, we barely evaluate an integral from the definitioin per se, i.e., partition the integrating interval, form Riemann sum, then take limit as the mesh of the partition approaches zero. Instead, we evaluate an integral by applying the Fundamental Theorem of Calculus. Though in stochastic calculus the Fundamental Theorem of Calculus does not really exist, we evaluate stochastic integrals by applying Ito’s formula.\n\nTheorem\n\\[\n\\int_a^b f(B_t) \\d B_t = F(B_t)\\Big|_{t=a}^b - \\frac12 \\int_a^b f'(B_t) \\d t,\n\\]\nwhere \\(F\\) is an anti-derivative of \\(f\\), i.e., \\(F'=f\\).\n\n\nTheorem\n\\[\n\\int_a^b f(t,B_t) \\d B_t = F(t,B_t)\\Big|_{t=a}^b - \\int_a^b \\left[F_t(t,B_t) + \\frac12 f_x(t,B_t)\\right] \\d t,\n\\]\nwhere \\(F_x = f\\), i.e., \\(F\\) is an anti-derivative of \\(f\\) with respect to \\(x\\).\n\nThe idea is, we find an anti-derivative of \\(f\\) (with respect to \\(x\\)), say, \\(F\\); apply Ito’s formula to \\(F\\), then rearrange terms.\nHowever, the price we pay is that in general the last (Riemann) integral on the right hand side usually has no simple analytical expression."
  },
  {
    "objectID": "NSD_Lec02-StochCal_Summer2025.html#examples-of-stochastic-integral-evaluation",
    "href": "NSD_Lec02-StochCal_Summer2025.html#examples-of-stochastic-integral-evaluation",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "Examples of stochastic integral evaluation",
    "text": "Examples of stochastic integral evaluation\n\nEvaluate the stochastic integral \\(\\displaystyle \\int_0^t B_s \\d B_s\\).  Note that in this case \\(f(x) = x\\). Hence an anti-derivative of \\(f\\) is \\(\\displaystyle F(x) = \\frac{x^2}2\\).  Apply Ito’s formula to \\(F\\) we have\n\\[\\begin{align*}\n  & \\d F(B_t) = \\d\\left(\\frac{B_t^2}2\\right) = B_t \\d B_t + \\frac12 \\d t \\\\\n  &\\Longrightarrow \\frac{B_T^2}2 - \\frac{B_0^2}2 = \\int_0^T B_t \\d B_t + \\frac12 \\int_0^T \\d t \\\\\n  &\\Longrightarrow \\int_0^T B_t \\d B_t = \\frac12(B_T^2 - T)\n  \\end{align*}\\]\nEvaluate the stochastic integral \\(\\displaystyle \\int_0^t se^{B_s} \\d B_s\\).  Note that in this case \\(f(t,x) = t e^x\\). Hence an anti-derivative \\(F\\) of \\(f\\) is \\(F(t,x) = t e^x\\).  Apply Ito’s formula to \\(F\\) we have\n\\[\\begin{align*}\n  & \\d F(t,B_t) = \\d\\left(t e^{B_t} \\right) = e^{B_t} \\d t + te^{B_t} \\d B_t + \\frac12 te^{B_t} \\d t \\\\\n  &\\Longrightarrow T e^{B_T} = \\int_0^T t e^{B_t} \\d B_t + \\int_0^T e^{B_t} \\left(1 + \\frac t2 \\right) \\d t \\\\\n  &\\Longrightarrow \\int_0^T t e^{B_t} \\d B_t = T e^{B_T} - \\int_0^T e^{B_t} \\left(1 + \\frac t2 \\right) \\d t\n  \\end{align*}\\]"
  },
  {
    "objectID": "NSD_Lec02-StochCal_Summer2025.html#applications-of-itos-formula-ii-solving-sdes",
    "href": "NSD_Lec02-StochCal_Summer2025.html#applications-of-itos-formula-ii-solving-sdes",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "Applications of Ito’s formula II: Solving SDEs",
    "text": "Applications of Ito’s formula II: Solving SDEs\nA stochastic differential equation (SDE) is an differential equation with random noise of the form\n\\[\n\\d X_t = \\mu(X_t,t) \\d t + \\sigma (X_t,t) \\d B_t\n\\]\n注: ODE (Ordinary Differential Equation) 是指一微分方程的未知数是单一自变量的函数.\nIn cases, we can solve SDEs by applying Ito’s formula to certain function of \\(X_t\\). We demonstrate the technique by solving the following two very important examples.\n\nGeometric Brownian motion/Black-Scholes model\n\\(\\d X_t = \\mu X_t \\d t + \\sigma X_t \\d B_t\\), where \\(\\mu\\) and \\(\\sigma\\) are constants.\n注: \\(\\sigma X_t \\d B_t\\) 表示当前的 risk. \\(\\mu X_t \\d t\\) 表示收益.\nTo solve it, we apply Ito’s formula to \\(\\log X_t\\).\nSolution: 我们可以视作: \\(f(t, X_t) = \\log X_t\\), 那么 \\(f_t = 0\\), \\(\\displaystyle f_x = \\frac{1}{x}\\), \\(\\displaystyle f_{xx} = - \\frac{1}{x^2}\\). \\[\\begin{align*}\n  \\d \\log X_t &=  \\frac{\\d X_t}{X_t} - \\frac{1}{2 X_t^2} (\\d X_t)^2 = \\mu \\d t + \\sigma \\d B_t - \\frac{1}{2 X_t^2} (\\d X_t)^2 \\\\\n  &= \\mu \\d t + \\sigma \\d B_t - \\frac{1}{2 X_t^2} (\\sigma^2 X_t^2 \\d t) = \\left(\\mu - \\frac12 \\sigma^2 \\right) \\d t + \\sigma \\d B_t \\\\\n  \\end{align*}\\] 注: 最后一步别的高阶项都被舍弃了.\n两边同时进行积分, 得到: \\[\\begin{align*}\n  \\log X_t - \\log X_0 &= \\left(\\mu - \\frac12 \\sigma^2 \\right) t + \\int_0^t \\sigma \\d B_s \\\\\n  &= \\left(\\mu - \\frac12 \\sigma^2 \\right) t + (\\sigma B_t) \\Big|_{s=0}^t - \\frac12 \\int_0^t 0 \\d s \\\\\n  &= \\left(\\mu - \\frac12 \\sigma^2 \\right) t + \\sigma B_t.\n  \\end{align*}\\]\n所以: \\[\n  X_t = X_0 \\exp\\left( \\left(\\mu - \\frac12 \\sigma^2 \\right) t + \\sigma B_t \\right).\n  \\]\n注: 设投资组合回报率为 \\(r_p\\), 基准指数回报率为 \\(r_b\\), 那么:\n\\[\n  \\text{相对回报} = \\frac{1 + r_p}{1 + r_b} \\approx r_p - r_b.\n  \\]\n\n绝对收益是指投资的费用后实际回报.\n相对收益就是绝对收益与某些基准收益之间的差. 一般在我们买入基金产品的时候, 基金产品会有一个基准作为比较, 比如上证综指、沪深300指数、中证1000指数等. 我们买入基金的绝对收益减去比较基准同样时间区间的绝对收益, 就是该基金相对于基准的相对收益.\n\nOrnstein-Uhlenbeck process/Vasicek model\n\\(\\d X_t = \\lambda(m - X_t) \\d t + \\sigma \\d B_t\\), where \\(m\\), \\(\\lambda\\), and \\(\\sigma\\) are constants.\nTo solve it, we apply Ito’s formula to \\(e^{\\lambda t} X_t\\).\nSolution: 我们可以视作: \\(f(t, X_t) = e^{\\lambda t} X_t\\), 那么 \\(f_t = \\lambda e^{\\lambda t} X_t\\), \\(f_x = e^{\\lambda t}\\), \\(f_{xx} = 0\\). \\[\\begin{align*}\n  \\d (e^{\\lambda t} X_t) &= \\lambda e^{\\lambda t} X_t \\d t + e^{\\lambda t} \\d X_t + 0 \\\\\n  &= \\lambda e^{\\lambda t} X_t \\d t + e^{\\lambda t} \\left[ \\lambda(m - X_t) \\d t + \\sigma \\d B_t \\right] \\\\\n  &= \\left[ \\lambda e^{\\lambda t} X_t + \\lambda e^{\\lambda t} (m - X_t) \\right] \\d t + e^{\\lambda t} \\sigma \\d B_t \\\\\n  &= \\lambda m e^{\\lambda t} \\d t + e^{\\lambda t} \\sigma \\d B_t.\n  \\end{align*}\\]\n两边同时进行积分, 得到: \\[\\begin{align*}\n  e^{\\lambda t} X_t - X_0 &= \\lambda m \\int_0^t e^{\\lambda s} \\d s + \\int_0^t e^{\\lambda s} \\sigma \\d B_s \\\\\n  &= \\lambda m \\frac{e^{\\lambda t} - 1}{\\lambda} + \\sigma \\int_0^t e^{\\lambda s} \\d B_s \\\\\n  &= m (e^{\\lambda t} - 1) + \\sigma \\int_0^t e^{\\lambda s} \\d B_s.\n  \\end{align*}\\]\n所以最后为: \\[\n  X_t = e^{-\\lambda t} \\left[ X_0 + m (e^{\\lambda t} - 1) + \\sigma \\int_0^t e^{\\lambda s} \\d B_s \\right].\n  \\]\n\n\nRemark\nGeometric Brownian motion and Ornstein-Uhlenbeck process are special cases of the so called linear SDEs which has the general form\n\\[\n\\d X_t = (\\mu_1 X_t + \\mu_0) \\d t + (\\sigma_1 X_t + \\sigma_0) \\d B_t.\n\\]\nSuch SDEs have “closed form” solutions.\n\n\nEuler-Maruyama Scheme\n现在我们考虑模拟 \\(\\d X_t = \\mu(X_t) \\d t + \\sigma(X_t) \\d B_t\\).\n那么模拟的方法就是:\n\\[\nX_{t_{n+1}} = X_{t_n} + \\mu(X_{t_n}) \\Delta t + \\sigma(X_{t_n}) \\Delta B_{t_n}.\n\\]\n用代码表示就是:\ndef euler_maruyama(X0, mu, sigma, T, N):\n    dt = T / N\n    X = np.zeros(N + 1)\n    X[0] = X0\n    for n in range(N):\n        dB = np.random.normal(0, np.sqrt(dt))  # simulate dB_t\n        X[n + 1] = X[n] + mu(X[n]) * dt + sigma(X[n]) * dB\n    return X\n\n丸山儀四郎\n\n\n\n当伊藤清在 1942 年发表一篇关于随机微分方程的论文时, 丸山立即认识到这项研究的重要性, 并立即发表了一系列关于随机微分方程和马尔可夫过程的论文. 丸山因其 1955 年关于随机微分方程数值解的微分近似的收敛性质的工作而闻名, 现在称为欧拉-丸山方法."
  },
  {
    "objectID": "NSD_Lec02-StochCal_Summer2025.html#simulation-of-the-ornstein-uhlenbeck-process",
    "href": "NSD_Lec02-StochCal_Summer2025.html#simulation-of-the-ornstein-uhlenbeck-process",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "Simulation of the Ornstein-Uhlenbeck process",
    "text": "Simulation of the Ornstein-Uhlenbeck process\n\n##### The code simulates the OU process dX = lambda (m - X) dt + sigma dB\n# by Euler-Maruyama scheme\n\n# Parameters of the OU process \nlmbda, m, sigma = 5, 0.5, 0.2\nx0, T = -2, 1\n\n# number of paths and number of time steps\nn_sim, n_steps = 10_000, 100\n\n# initialize X\nX = np.ones([n_sim, n_steps+1])*x0\n\n# Euler-Maruyama scheme\ndt = T/n_steps\nfor i in range(n_steps):\n    db = norm.rvs(size=n_sim)\n    db = db - db.mean()\n    db = db/db.std()\n    # NOTE: db is a standard normal random variable, so we scale it by sqrt(dt)\n    X[:,i+1] = X[:,i] + lmbda*(m - X[:,i])*dt + sigma*np.sqrt(dt)*db\n\n# plot\nplt.figure(figsize=(12, 8))\nt = np.arange(0, T+dt, dt)\n\n# histograms at different times\nplt.subplot(2, 2, 1)\ntime = 0.02 # 0.5, 0.8\nsns.histplot(X[:,t==time], bins=30, stat='density', label=f'$t={time}$', element='step')\nsns.histplot(X[:,-1], bins=30, stat='density', label=f'$t={T}$', color='lightgreen', element='step')\nplt.legend()\n\n# time evolution of mean\nplt.subplot(2, 2, 2)\nplt.plot(t, X.mean(axis=0))\nplt.xlabel('$t$')\nplt.ylabel('sample mean')\n\n# time evolution of variance\nplt.subplot(2, 2, 3)\nplt.plot(t, X.var(axis=0))\nplt.xlabel('$t$')\nplt.ylabel('sample variance');\n\n\n\n\n\n\n\n\n\n(np.sin(X[:, -1]**2)).mean()\n\nnp.float64(0.23676791974798134)"
  },
  {
    "objectID": "NSD_Lec02-StochCal_Summer2025.html#stochastic-differential-equation",
    "href": "NSD_Lec02-StochCal_Summer2025.html#stochastic-differential-equation",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "Stochastic differential equation",
    "text": "Stochastic differential equation\nLet \\((\\Omega,\\cF_t,\\P)\\) be a filtered probability space and \\(W_t\\) a Brownian motion defined on it. A stochastic differential equation (SDE) driven by the Brownian motion \\(W_t\\) is an equation of the form\n\\[\n\\d X_t = \\mu(X_t,t) \\d t + \\sigma(X_t,t) \\d W_t, \\quad X_0 = x\n\\]\nor in integral form\n\\[\nX_t = x_0 + \\int_0^t \\mu(X_s,s) \\d s + \\int_0^t \\sigma(X_s,s) \\d W_s.\n\\]\nAs usual, \\(\\mu(x,t)\\) is referred to as the drift part and \\(\\sigma(x,t)\\) the diffusion part."
  },
  {
    "objectID": "NSD_Lec02-StochCal_Summer2025.html#connection-to-partial-differential-equation",
    "href": "NSD_Lec02-StochCal_Summer2025.html#connection-to-partial-differential-equation",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "Connection to partial differential equation",
    "text": "Connection to partial differential equation\nStochastic differential equation provides a way to numerically solve second order parabolic partial differential equations by Monte Carlo simulation. The key point is a stochastic representation of the solution to partial differential equations which we develop in the following.\nLet \\(X_t\\) be the diffusion process driven by\n\\[\n  \\d X_t = \\mu(X_t,t) \\d t + \\sigma(X_t,t) \\d W_t.\n\\]\nWe shall suppress the dependence on \\(x,t\\) of \\(\\mu\\) and \\(\\sigma\\) for notational simplicity.\n\nTheorem\nLet \\(u = u(x,t)\\) be the solution to the terminal value problem\n\\[\\begin{align*}\n  & u_t + \\frac{\\sigma^2}2 u_{xx} + \\mu u_x = 0, \\quad t &lt; T, \\\\\n  & u(x,T) = h(x).  \n\\end{align*}\\]\nThen \\(u\\) has the representation\n\\[\n  u(x,t) = \\E_{t,x}\\left[h(X_T)\\right],\n\\]\nwhere \\(\\E_{t,x}[\\cdot]\\) denotes the conditional expectation \\(\\E[\\cdot|X_t = x]\\).\n\n\nProof\nApplying Ito’s formula to \\(u(X_t,t)\\) yields\n\\[\\begin{align*}\n  u(X_T,T) - u(X_t,t) &= \\int_t^T \\sigma(X_s,s)u_x(X_s,s) \\d W_s + \\int_t^T \\left[ u_t + \\frac{\\sigma^2}2 u_{xx} + \\mu u_x \\right]\\d s  \\\\\n  &= \\int_t^T \\sigma(X_s,s)u_x(X_s,s) \\d W_s\n\\end{align*}\\]\nsince \\(u\\) satisfies the PDE\n\\[\nu_t + \\frac{\\sigma^2}2 u_{xx} + \\mu u_x = 0.\n\\]\nThus taking conditional expectation \\(\\E_{t,x}[\\cdot]\\) on both sides and taking into account the terminal condition \\(u(x,T) = h(x)\\) we end up with\n\\[\n  u(x,t) = \\E_{t,x}[h(X_T)].\n\\]"
  },
  {
    "objectID": "NSD_Lec02-StochCal_Summer2025.html#the-feynman-kac-formula",
    "href": "NSD_Lec02-StochCal_Summer2025.html#the-feynman-kac-formula",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "The Feynman-Kac formula",
    "text": "The Feynman-Kac formula\nLet \\(u = u(x,t)\\) be the solution to the terminal value problem\n\\[\\begin{align*}\n  & u_t + \\frac{\\sigma^2}2 u_{xx} + \\mu u_x = V(x,t) u, \\quad t &lt; T,  \\\\\n  & u(x,T) = h(x).  \n\\end{align*}\\]\nThen \\(u\\) has the representation\n\\[\n  u(x,t) = \\E_{t,x}\\left[e^{-\\int_t^T V(X_s,s) \\d s}h(X_T)\\right],\n\\]\nwhere \\(\\E_{t,x}[\\cdot]\\) denotes the conditional expectation \\(\\E[\\cdot|X_t = x]\\). This is the celebrated Feynman-Kac formula.\n注: Feynman-Kac 公式将 PDE 的解转化为随机过程的期望. \\(e^{-\\int_t^T V(X_s,s) \\d s}\\) 是对路径的贴现效应, \\(h(X_T)\\) 是终端支付.\n贴现效应: 本质是货币时间价值的体现, 即未来资金在当前时点的折现. 其核心逻辑是“现在的钱比未来的钱更值钱”, 因此需通过扣除利息补偿资金的时间成本.\n终端支付: 指票据到期时, 持票人向付款人(或承兑人)提示票据并要求支付票面金额的行为.\n\nProof of Feynman-Kac formula\nApplying Ito’s formula to \\(u(X_t,t)e^{-\\int_0^t V(X_s,s)\\d s}\\) yields\n\\[\\begin{align*}\n  & \\d \\left[ u(X_t,t)e^{-\\int_0^t V(X_s,s)\\d s} \\right] \\\\\n  &= e^{-\\int_0^t V(X_s,s)\\d s}\\left[ u_t(X_t,t) \\d t - V(X_t,t) u(X_t,t) \\d t + u_x(X_t,t) \\d X_t + \\frac12 u_{xx}(X_t,t) \\d [X]_t \\right]  \\\\\n  &= e^{-\\int_0^t V(X_s,s)\\d s}\\left[ \\left\\{ u_t(X_t,t) + \\frac{\\sigma^2(X_t,t)}2 u_{xx}(X_t,t) + \\mu u_x(X_t,t) - V(X_t,t) u(X_t,t) \\right\\} \\d t + \\sigma(X_t,t) u_x(X_t,t) \\d B_t \\right]  \\\\\n  &= e^{-\\int_0^t V(X_s,s)\\d s} \\sigma(X_t,t) u_x(X_t,t) \\d B_t\n\\end{align*}\\]\nsince \\(u\\) satisfies the PDE\n\\[\nu_t + \\frac{\\sigma^2}2 u_{xx} + \\mu u_x = V(x,t) u.\n\\]\nIn integral form\n\\[\\begin{align*}\n  u(X_T,T)e^{-\\int_0^T V(X_s,s)\\d s} - u(X_t,t)e^{-\\int_0^t V(X_s,s)\\d s} &=& \\int_t^T e^{-\\int_0^\\tau V(X_s,s)\\d s} \\sigma(X_\\tau,\\tau) u_x(X_\\tau,\\tau) \\d B_\\tau\n\\end{align*}\\]\ntherefore, by dividing on both sides the term \\(e^{-\\int_0^t V(X_s,s)\\d s}\\) we have\n\\[\\begin{align*}\n  u(X_T,T)e^{-\\int_t^T V(X_s,s)\\d s} - u(X_t,t) &=& \\int_t^T e^{-\\int_t^\\tau V(X_s,s)\\d s} \\sigma(X_\\tau,\\tau) u_x(X_\\tau,\\tau) \\d B_\\tau.\n\\end{align*}\\]"
  },
  {
    "objectID": "NSD_Lec02-StochCal_Summer2025.html#richard-phillips-feynman",
    "href": "NSD_Lec02-StochCal_Summer2025.html#richard-phillips-feynman",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "Richard Phillips Feynman",
    "text": "Richard Phillips Feynman\n\n\n\nCourtesy: Photo from Wikipedia"
  },
  {
    "objectID": "NSD_Lec02-StochCal_Summer2025.html#marek-kac",
    "href": "NSD_Lec02-StochCal_Summer2025.html#marek-kac",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "Marek Kac",
    "text": "Marek Kac\n\n\n\nCourtesy: Photo from Wikipedia\nQuoted from the Wikipage:\n\nWhen Kac and Richard Feynman were both on the Cornell faculty he went to a lecture of Feynman’s and saw that the two of them were working on the same thing from different directions. The Feynman-Kac formula resulted, which proves rigorously the real case of Feynman’s path integrals. The complex case, which occurs when a particle’s spin is included, is still unproven."
  },
  {
    "objectID": "NSD_Lec02-StochCal_Summer2025.html#adding-nonhomogeneous-term",
    "href": "NSD_Lec02-StochCal_Summer2025.html#adding-nonhomogeneous-term",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "Adding nonhomogeneous term",
    "text": "Adding nonhomogeneous term\nLet \\(u = u(x,t)\\) be the solution to the terminal value problem\n\\[\\begin{align*}\n  & u_t + \\frac{\\sigma^2}2 u_{xx} + \\mu u_x = f(x,t), \\quad t &lt; T,  \\\\\n  & u(x,T) = h(x).  \n\\end{align*}\\]\nThen \\(u\\) has the representation\n\\[\n  u(x,t) = \\E_{t,x}\\left[h(X_T) - \\int_t^T f(X_\\tau,\\tau) \\d\\tau\\right],\n\\]\nwhere \\(\\E_{t,x}[\\cdot]\\) denotes the conditional expectation \\(\\E[\\cdot|X_t = x]\\)."
  },
  {
    "objectID": "NSD_Lec02-StochCal_Summer2025.html#backward-second-order-parabolic-pdes",
    "href": "NSD_Lec02-StochCal_Summer2025.html#backward-second-order-parabolic-pdes",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "Backward second order parabolic PDEs",
    "text": "Backward second order parabolic PDEs\nFinally, we have the stochastic representation for any backward second order parabolic linear PDE with terminal condition as follows.\n\nTheorem\nLet \\(u = u(x,t)\\) be the solution to the terminal value problem\n\\[\\begin{align*}\n  & u_t + \\frac{\\sigma^2}2 u_{xx} + \\mu u_x = V(x,t) u + f(x,t), \\quad t &lt; T,  \\\\\n  & u(x,T) = h(x).  \n\\end{align*}\\]\nThen \\(u\\) has the representation\n\\[\n  u(x,t) = \\E_{t,x}\\left[e^{-\\int_t^T V(X_s,s)\\d s}h(X_T) - \\int_t^T e^{-\\int_t^\\tau V(X_s,s)\\d s} f(X_\\tau,\\tau) \\d\\tau\\right],\n\\]\nwhere \\(\\E_{t,x}[\\cdot] = \\E[\\cdot|X_t = x]\\) is the conditional expectation. Recall that \\(X_t\\) denotes the diffusion process driven by\n\\[\n  \\d X_t = \\mu(X_t,t) \\d t + \\sigma(X_t,t) \\d W_t.\n\\]"
  },
  {
    "objectID": "NSD_Lec02-StochCal_Summer2025.html#lévy-area",
    "href": "NSD_Lec02-StochCal_Summer2025.html#lévy-area",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "Lévy area",
    "text": "Lévy area\nAs an application of the Feynmann-Kac formula, we demonstrate how to calculate the characteristic function of the Lévy area. Let \\((W_t, Z_t)\\) be a two-dimensional Brownian motion. The Lévy area \\(A_t\\) is defined by\n\\[\nA_t = \\frac12 \\int_0^t W_s \\d Z_s - Z_s \\d W_s\n\\]\nwhich represents the (stochastic) area of the region enclosed by the two-dimensional Brownian motion \\((W_t, Z_t)\\) and the radial cord.\nWe are interested in calculating the characteristic function of the Lévy area \\(A_t\\) at time \\(T\\), i.e,. the expectation\n\\[\n\\Eof{e^{i\\xi A_T}}\n\\]\nwhere \\(i = \\sqrt{-1}\\).\n\nCharacteristic function\nThe characteristic function is a way to describe a random variable \\(X\\). The characteristic function,\n\\[\n\\varphi_X(t) = \\Eof{e^{itX}},\n\\]\na function of t, determines the behavior and properties of the probability distribution of \\(X\\). It is equivalent to a probability density function or cumulative distribution function, since knowing one of these functions allows computation of the others, but they provide different insights into the features of the random variable. In particular cases, one or another of these equivalent functions may be easier to represent in terms of simple standard functions."
  },
  {
    "objectID": "NSD_Lec02-StochCal_Summer2025.html#paul-lévy",
    "href": "NSD_Lec02-StochCal_Summer2025.html#paul-lévy",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "Paul Lévy",
    "text": "Paul Lévy\n\n\n\nCourtesy: Photo from The Oberwolfach Photo Collection.\nRama Cont in an article wrote:\n\n“He made major contributions to the study of Gaussian variables and processes, the law of large numbers, the central limit theorem, stable laws, infinitely divisible laws and pioneered the study of processes with independent and stationary increments, now known as Lévy processes.”\n\nMichael Loeve:\n\n“Paul Lévy was a painter in the probabilistic world. Like the very great painting geniuses, his palette was his own and his paintings transmuted forever our vision of reality… His three main, somewhat overlapping, periods were: the limit laws period, the great period of additive processes and of martingales painted in pathtime colours, and the Brownian pathfinder period.”\n\n\n# The code demonstrate the region enclosed by a 2-dim Brownian \n# motion and the radial cord\n# number of steps \nn_steps = 10_000\n#10_000\n\n# terminal time\nT = 1   \n\ndt = T/n_steps\n\ndW = norm.rvs(size=n_steps)*np.sqrt(dt)\ndZ = norm.rvs(size=n_steps)*np.sqrt(dt)\nW = np.append(0, dW.cumsum())\nZ = np.append(0, dZ.cumsum())\n\nplt.figure(figsize=(10, 6))\nplt.plot(W, Z, lw=1)\nplt.plot([W[-1], W[0]], [Z[-1], Z[0]], 'ro-', lw=1);"
  },
  {
    "objectID": "NSD_Lec02-StochCal_Summer2025.html#distribution-of-lévy-area",
    "href": "NSD_Lec02-StochCal_Summer2025.html#distribution-of-lévy-area",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "Distribution of Lévy area",
    "text": "Distribution of Lévy area\nFirst notice that \\(A_t\\) is a (continuous, Brownian) martingale with quadratic variation \\([A]_t\\) given by\n\\[\n\\d [A]_t = \\frac14 (W_t^2 + Z_t^2) \\d t\n\\]\nsince \\(W_t\\) and \\(Z_t\\) are independent. Let \\(R_t = W_t^2 + Z_t^2\\). Hence,\n\\[\nA_t \\overset{d}{=} B_{\\frac{1}{4} \\int_0^t R_s \\, \\d s}\n\\]\nwhere \\(B_t\\) is a Brownian motion independent of \\(R_t\\). In other words, \\(A_t\\) is distributed as a Brownian motion running in the random time \\(\\displaystyle \\frac14 \\int_0^t R_s \\d s\\)."
  },
  {
    "objectID": "NSD_Lec02-StochCal_Summer2025.html#bessel-squared-process",
    "href": "NSD_Lec02-StochCal_Summer2025.html#bessel-squared-process",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "Bessel squared process",
    "text": "Bessel squared process\nNote that, by applying Ito’s formula we obtain that \\(R_t\\) satisfies the SDE\n\\[\\begin{align*}\n\\d R_t &= 2W_t \\d W_t + 2 Z_t \\d Z_t + 2\\d t \\\\\n&= 2 \\sqrt{R_t} \\left( \\frac{W_t}{\\sqrt{R_t}} \\d W_t + \\frac{Z_t}{\\sqrt{R_t}} \\d Z_t \\right) + 2 \\d t \\\\\n&= 2 \\sqrt{R_t} \\d M_t + 2 \\d t,\n\\end{align*}\\]\nwhere \\(\\displaystyle \\d M_t = \\frac{W_t}{\\sqrt{R_t}} \\d W_t + \\frac{Z_t}{\\sqrt{R_t}} \\d Z_t\\) is a Brownian motion.\n\nNote\n\\(R_t\\) is known as the Bessel squared process."
  },
  {
    "objectID": "NSD_Lec02-StochCal_Summer2025.html#characteristic-function-of-lévy-area",
    "href": "NSD_Lec02-StochCal_Summer2025.html#characteristic-function-of-lévy-area",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "Characteristic function of Lévy area",
    "text": "Characteristic function of Lévy area\nIt follows that the characteristic function \\(A_t\\) is related to the process \\(R_t\\) as\n\\[\\begin{align*}\n& \\Eof{e^{i\\xi A_t}}\n= \\Eof{e^{i\\xi B_{\\frac14 \\int_0^t R_s \\d s}}}\n= \\Eof{e^{\\frac{-\\xi^2}8 \\int_0^t R_s \\d s}}.\n\\end{align*}\\]\nThus, it is equivalent to determine the last expectation in the equation above. To that end, we shall apply the Feynman-Kac formula. Consider\n\\[\nu(t, r) = \\Eof{\\left. e^{-\\frac{\\xi^2}8 \\int_t^T R_s \\d s} \\right| R_t=r}.\n\\]\nFeynman-Kac formula implies that \\(u\\) satisfies the (backward) PDE\n\\[\nu_t + 2 r u_{rr} + 2u_r = \\frac{\\xi^2}8 r u\n\\]\nwith terminal condition \\(u(T, r) = 1\\)."
  },
  {
    "objectID": "NSD_Lec02-StochCal_Summer2025.html#solving-the-terminal-value-problem",
    "href": "NSD_Lec02-StochCal_Summer2025.html#solving-the-terminal-value-problem",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "Solving the terminal value problem",
    "text": "Solving the terminal value problem\nAssume the ansatz for \\(u\\)\n\\[\nu(t, r) = e^{H_1 r + H_0}.\n\\]\nSince\n\\[\\begin{align*}\n& u_t = \\left(\\dot H_1 r + \\dot H_0\\right)u \\\\\n& u_r = H_1 u \\\\\n& u_{rr} = H_1^2 u,\n\\end{align*}\\]\nplugging the ansatz into the PDE yields\n\\[\\begin{align*}\n& \\left(\\dot H_1 r + \\dot H_0 \\right) + 2 r H_1^2 + 2 H_1 = \\frac{\\xi^2}8 r.\n\\end{align*}\\]\nBy comparing the coefficients we obtain the system of ODEs\n\\[\\begin{align*}\nr &: \\dot H_1 + 2 H_1^2 = \\frac{\\xi^2}8 \\\\\n1 &: \\dot H_0 = -2H_1\n\\end{align*}\\]\nwith terminal conditions \\(H_1(T) = H_0(T) = 0\\). The solution is given by\n\\[\\begin{align*}\n& H_1(t) = -\\frac\\xi4 \\tanh\\left(\\frac\\xi2 (T - t)\\right), \\\\\n& H_0(t) = -\\log\\cosh\\left(\\frac\\xi2(T - t) \\right).\n\\end{align*}\\]"
  },
  {
    "objectID": "NSD_Lec02-StochCal_Summer2025.html#characteristic-function-of-lévy-area-1",
    "href": "NSD_Lec02-StochCal_Summer2025.html#characteristic-function-of-lévy-area-1",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "Characteristic function of Lévy area",
    "text": "Characteristic function of Lévy area\nThus,\n\\[\\begin{align*}\nu(t, r) &= e^{-\\frac\\xi4 \\tanh\\left(\\frac\\xi2 (T - t)\\right)r - \\log\\cosh\\left(\\frac\\xi2(T - t)\\right)} \\\\\n&= {\\rm sech}\\left(\\frac\\xi2(T - t)\\right) e^{-\\frac\\xi4 \\tanh\\left(\\frac\\xi2 (T - t)\\right)r}\n\\end{align*}\\]\nFinally, we obtain the characteristic function of \\(A_T\\) as\n\\[\n\\Eof{e^{i\\xi A_T}} = u(0, 0) = {\\rm sech}\\left(\\frac\\xi2 T\\right).\n\\]"
  },
  {
    "objectID": "NSD_Lec02-StochCal_Summer2025.html#notes-of-the-lecture",
    "href": "NSD_Lec02-StochCal_Summer2025.html#notes-of-the-lecture",
    "title": "Topics in Quantitative Finance, Summer 2025",
    "section": "Notes of the Lecture",
    "text": "Notes of the Lecture\nThanks to 刘弘锌 (Liú Hóng Xīn) for his lecture notes.\n\n核心概念: 随机积分 vs. 经典积分\n\n问题背景\n\n在金融中, 计算资产价格路径的积分(如 PNL)需考虑随机性(如布朗运动).\n经典黎曼积分中, 选择左端点、右端点或中点不影响收敛结果; 但在随机积分中, 选择不同会导致本质差异.\n\n\n注: 资产价格路径(Asset Price Path):\n\n这是指某个资产(如股票、期权、债券)在一段时间内的价格变化轨迹;\n它通常被建模为一个随机过程, 因为未来价格存在不确定性;\n一般用 \\(S_t\\) 表示表示某资产在时间 \\(t\\) 的价格.\n\n注: PNL (Profit and Loss):\n\nPNL 是指某个投资组合或交易策略在一段时间内的利润和损失;\nPNL 可以表达为投资组合价值的变化 \\[\n\\text{PNL} = \\int_0^T \\phi_t \\d S_t,\n\\] 其中 \\(\\phi_t\\) 是持仓(投资组合中持有的资产数量), \\(S_t\\) 是资产价格.\n\n\n离散时间交易策略类比\n\n我们设时间点为 \\(T_0, T_1, T_2, ...\\), 价格 \\(P_0, P_1, P_2, ...\\), 时间间隔 \\(\\Delta t_i = T_i - T_{i-1}\\).\n积分定义方式:\n\n左端点规则(Left Point Rule): \\[\n\\int_{T_0}^{T_n} P_t \\d t \\approx \\sum_{i=1}^n P_{i-1} \\Delta t_i.\n\\] 金融意义: 在 \\(T_{i-1}\\) 时刻, 根据当前已知价格 \\(P_{i-1}\\) 决定持仓量.\n右端点规则(Right Point Rule): \\[\n   \\int_{T_0}^{T_n} P_t \\d t \\approx \\sum_{i=1}^n P_i \\Delta t_i.\n   \\] 金融意义: 在 \\(T_{i-1}\\) 时刻, 根据未来价格 \\(P_i\\) 决定持仓量. 现实中不可行.\n中点规则(Mid Point Rule): \\[\n   \\int_{T_0}^{T_n} P_t \\d t \\approx \\sum_{i=1}^n P_{i-1/2} \\Delta t_i,\n   \\] 其中 \\(\\displaystyle P_{i-1/2} = \\frac{P_{i-1} + P_i}{2}\\).\n\n\n关键结论: 随机积分必须固定选择左端点\n\n金融逻辑: 交易决策只能基于当前已知信息(历史价格), 无法依赖未来价格.\n数学逻辑: 右端点或中点规则会导致结果发散, 无法收敛到一致解. Refer to Which rule rules?.\n\n\n\n\nItô 积分的金融意义\n\nItô 积分的必要性: 在资产定价中(如期权模型), 必须使用 Itô 积分以保证:\n\n交易策略可执行(无未来信息);\n结果符合无套利原则(鞅性质). Refer to Technical note: martingale conditions.\n\nItô 引理的根源: 经典链式法则在随机过程中失效, \\(\\d (P_t^2) \\neq 2 P_t \\d P_t\\), 实际上为: \\[\n\\d (P_t^2) 2 P_t \\d P_t + (\\d P_t)^2,\n\\] 额外项 \\((\\d P_t)^2\\) 来自二次变差. Refer to Ito’s formula for Brownian motion.\n\n\n\nItô 过程的本质与金融建模\n定义: \\[\n\\d X_t = \\sigma_t \\d B_t + b_t \\d t.\n\\]\n\n扩散项 \\(\\sigma_t \\d B_t\\) 代表随机波动, 如资产价格的随机性.\n漂移项 \\(b_t \\d t\\) 代表趋势或漂移, 如资产价格的长期增长趋势.\n\n关键性质: \\[\n\\d [X]_t = \\sigma_t^2 \\d t.\n\\]\n\n物理意义: 路径累积波动率.\n金融意义: 期权定价中的波动率参数 (如 VIX 指数).\n实际上在 \\(\\displaystyle \\frac{\\d S_t}{S_t} = \\mu \\d t + \\sigma \\d B_t\\) 模型中, \\(\\sigma\\) 就是波动率.\n\n注: VIX 指数 (恐慌指数, Volatility Index) 是衡量市场预期波动率的指标, 通常用于期权定价和风险管理.\n\n\n\n\n\n\n\n\n过程\n随机微分方程\n金融应用\n\n\n\n\n几何布朗运动\n\\(\\d S_t = \\mu S_t \\d t + \\sigma S_t \\d B_t\\)\n股票价格 (Black-Scholes)\n\n\nOrnstein-Uhlenbeck\n\\(\\d X_t = \\lambda (\\theta - X_t)\\d t + \\sigma \\d B_t\\)\n利率模型 (Vasicek)\n\n\n\n\n\nItô 公式的金融直觉\n公式: \\[\\begin{align*}\n\\d f(t, X_t) &= f_t(t, X_t) \\d t + f_x(t, X_t) \\d X_t + \\frac{1}{2} f_{xx}(t, X_t) (\\d X_t)^2 \\\\\n&= f_t(t, X_t) \\d t + f_x(t, X_t) (\\sigma_t \\d B_t + b_t \\d t) + \\frac{1}{2} f_{xx}(t, X_t) \\sigma_t^2 \\d t.\n\\end{align*}\\]\n\n新漂移项: \\[f_t + b_t f_x + \\frac{1}{2} \\sigma^2 f_{xx}\\] 代表了时间变化、漂移和波动率对函数 \\(f\\) 的影响.\n新扩散项​: \\[f_x \\sigma_t \\d B_t\\] 代表了随机波动对函数 \\(f\\) 的影响. (风险暴露)\n\n\\[\n\\d f(t, X_t) = \\underbrace{\\left( f_t + b_t f_x + \\frac{1}{2} \\sigma_t^2 f_{xx} \\right)}_{\\text{确定性变化(漂移项)}} \\d t\n+ \\underbrace{f_x \\sigma_t}_{\\text{风险暴露}} \\d B_t\n\\]\n\nExample: 期权价格对股票价格\n设 \\(X_t = S_t\\) 是股票价格, \\(f(t, S_t)\\) 是欧式看涨期权的价格(如 Black-Scholes 期权价值):\n\n\\(\\displaystyle f_x = \\frac{\\partial f}{\\partial S}\\) 是期权对标的资产价格的敏感度，叫作 Delta;\n\\(\\sigma \\d B_t\\)：标的资产的波动部分;\n\n那么期权价格的随机波动项就是:\n\\[\n\\underbrace{f_x}_{\\Delta} \\cdot \\underbrace{\\sigma \\d B_t}_{\\text{股票的风险}}\n\\quad = \\quad \\text{期权的风险暴露}\n\\]\n\n\n\n\n\n\n\n\n\n概念\n数学形式\n金融意义\n解释\n\n\n\n\nWiener 积分\n\\(\\displaystyle \\int_0^T f(t) \\, \\d B_t\\)\n确定性策略的噪声暴露\n表示一个固定策略 \\(f(t)\\) 在布朗运动下受到的总“扰动影响”.这衡量了非自适应投资策略对市场波动的累计敏感度.\n\n\nItô 积分\n\\(\\displaystyle \\int_0^T \\phi_t \\, \\d X_t\\)\n动态策略的盈亏分解\n自适应策略 \\(\\phi_t\\) 持有某资产 \\(X_t\\), 这个积分即为投资策略的 PNL (收益), 是对金融交易最基本的建模方式.\n\n\nItô 过程\n\\(\\d X_t = \\sigma_t \\, \\d B_t + b_t \\, \\d t\\)\n资产价格的趋势-噪声分离模型\n描述资产价格如何受到系统性趋势 (\\(b_t\\)) 和不确定波动 (\\(\\sigma_t\\)) 的共同影响.\n\n\nItô 公式\n\\(\\d f = (\\cdots)\\, \\d t + (\\cdots) \\, \\d B_t\\)\n衍生品价值的风险-收益分解\n当 \\(f(t, X_t)\\) 是某种金融产品价值函数时, Itô 公式将其变动拆解为确定性收益和风险暴露两个部分, 体现风险定价的核心机制.\n\n\n\n\n\n\n股票价格的随机模型\n股票价格 \\(S_t\\) 被建模为随机过程: \\[\n\\d S_t = \\mu S_t \\d t + \\sigma S_t \\d B_t,\n\\] 其中:\n\n漂移项 \\(\\mu S_t \\d t\\) 代表预期回报率 (Expected Return Rate);\n扩散项 \\(\\sigma S_t \\d B_t\\) 代表随机波动 (Volatility).\n金融意义: 股票价格的动态变化由确定的预期回报和随机风险组成.\n\n假设我们有一个函数 \\(f(S_t,t)\\) 光滑, 那么根据 Itô 公式: \\[\n\\d f = \\left( \\frac{\\partial f}{\\partial t} + \\mu S_t \\frac{\\partial f}{\\partial S} + \\frac{1}{2} \\sigma^2 S_t^2 \\frac{\\partial^2 f}{\\partial S^2} \\right) \\d t + \\sigma S_t \\frac{\\partial f}{\\partial S} \\d B_t.\n\\]\n\n核心思想: 将复杂函数的动态分解为漂移项(预期回报)和扩散项(风险).\n用于衍生品 (如期权、远期合约) 的定价与风险管理.\n推导期权的 Delta (\\(\\displaystyle \\Delta = \\frac{\\partial f}{\\partial S}\\)) 和 Gamma (\\(\\displaystyle \\Gamma = \\frac{\\partial^2 f}{\\partial S^2}\\)).\n\n\n\n金融衍生品定价示例\n案例 1: 远期合约 (Forward Contract) 合约约定在时间 \\(T\\) 支付 \\(2S_T\\), 其价值为 \\(V_t = 2 S_t\\).\n\\[\n\\d V_t = 2 \\d S_t = 2 \\mu S_t \\d t + 2 \\sigma S_t \\d B_t.\n\\]\n案例 2: 欧式看涨期权 (European Call Option) 其价值为 \\(C(t, S_t) = S_t N(d_1) - K e^{-r(T-t)} N(d_2)\\), 其中 \\(K\\) 是行权价, \\(r\\) 是无风险利率.\n\n\n风险中性定价\n在风险中性世界中, 所有的资产的预期回报率等于无风险利率 \\(r\\).\n衍生品定价公式: \\[\nV_t = \\mathbb{E}^Q\\left[{e^{-r(T-t)}\\cdot \\text{Payoff}(S_T) | \\cF_t}\\right],\n\\] 这里的 \\(\\mathbb{E}^Q\\) 是风险中性测度下的期望值.\n\n\nOption Payoff\nAn option payoff diagram is a graphical representation of the net Profit/Loss made by the option buyers and sellers.\nCall Option: 自身有一个价格, 设为 \\(p\\); 同时买方拥有在到期日之前 (或到期时) 以行权价 \\(K\\) 买入标的资产的权利, 但没有义务 购买. 若到期时标的 \\(S &gt; K\\), 则有盈余, 等于 \\(S−K\\), 扣除买入时的溢价后才是真正盈利, 为 \\(S- K -p\\); 若 \\(S \\leq K\\), 选择不行权, 损失仅限于初始溢价 \\(p\\).\nPut Option: 同样有一个价格, 设为 \\(p\\); 买方拥有在到期日之前 (或到期时) 以行权价 \\(K\\) 卖出标的资产的权利, 但没有义务卖出. 若到期时标的 \\(S &lt; K\\), 则有盈余, 等于 \\(K−S\\), 扣除买入时的溢价后才是真正盈利, 为 \\(K - S - p\\); 若 \\(S \\geq K\\), 选择不行权, 损失仅限于初始溢价 \\(p\\).\n我们有一些 option 的 Strategy:\n\nLong Call: 买入看涨期权, 预期标的价格上涨.\nShort Call: 卖出看涨期权, 预期标的价格下跌或持平.\nLong Put: 买入看跌期权, 预期标的价格下跌.\nShort Put: 卖出看跌期权, 预期标的价格上涨或持平.\nLong Straddle: 同时买入看涨和看跌期权, 预期标的价格大幅波动.\nShort Straddle: 同时卖出看涨和看跌期权, 预期标的价格稳定.\nLong Strangle: 买入不同行权价的看涨和看跌期权, 预期标的价格大幅波动. Long strangles involve buying a call with a higher strike price and buying a put with a lower strike price.\nShort Strangle: 卖出不同行权价的看涨和看跌期权, 预期标的价格稳定."
  }
]